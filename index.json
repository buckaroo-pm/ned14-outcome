[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.3 [Linux] Visual Studio 2017 [Windows] XCode 9 [MacOS]  It is worth turning on C++ 17 if you can, as there are many usability and performance improvements. If your compiler implements the Concepts TS, it is worth turning support on. Support is automatically detected and used.\nPartially working compilers:\n clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "https://ned14.github.io/outcome/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Outcome v2 is feature complete, meeting the feedback from the Boost peer review in May 2017. It is an all new code base, written entirely from scratch during the month of June 2017. It has completed three months of maturation, and will shortly be sent back to Boost for a second peer review. As a result, consider this library to beta quality and subject change if a second review demands it.\nThat said, the essentials here are the same as they were in v1. Indeed most code written for v1 should be convertible to v2 without too much effort.\nUsage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On BSD:\nfetch https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  If you have curl installed:\ncurl -O -J -L https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  Otherwise, simply download the raw file from above and place it wherever it suits you.\nUsage from the Conan package manager (thanks to Th√©o Delrieu for contributing this support)\nAt the command line, add the bintray repo for Outcome to conan:\nconan remote add outcome https://api.bintray.com/conan/ned14/Outcome  Now simply add this to your Conan build:\n[requires] Outcome/master@ned14/stable  Outcome will be made available by Conan at \u0026lt;outcome.hpp\u0026gt;.\nUsage as a git submodule Given that v2 is still under development, it is currently best used as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout develop git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/include/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable branch containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://dedi5.nedprod.com/static/files/outcome-v2.0-source-latest.tar.xz\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 6.3, clang 4.0 MacOS: XCode 9 Windows: VS2017   Running the unit test suite To run the unit test suite you will need cmake 3.1 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.1 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/problem/",
	"title": "Incommensurate E types",
	"tags": [],
	"description": "",
	"content": "Back in the tutorial section on Default Actions, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now set E = std::error_code as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.\nWe thus strongly recommend to users that for any given piece of code, always using the same E type across the codebase is very wise, except where you explicitly want to prevent implicit propagation of failure up a call stack e.g. local failures in some domain specific piece of code.\nHowever it is unreasonable to expect that any non-trivial codebase can make do with E = std::error_code. This is why Outcome allows you to use custom E types which carry payload in addition to an error code, yet still have the Default Actions of std::error_code, including lazy custom exception throw synthesis.\nAll this is good, but if library A uses result\u0026lt;T, libraryA::failure_info\u0026gt;, and library B uses result\u0026lt;T, libraryB::error_info\u0026gt; and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.\nThe application writer has one of three choices:\n In the application, the form of result used is result\u0026lt;T, std::variant\u0026lt;E1, E2, ...\u0026gt;\u0026gt; where E1, E2 \u0026hellip; are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.\n One can translate/map the third party\u0026rsquo;s failure type into the application\u0026rsquo;s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.\n One can type erase the third party\u0026rsquo;s failure type into some application failure type, which can later be reconstituted if necessary. This is the cleanest solution with the least coupling issues and no problems with mis-mapping, but it almost certainly requires the use of malloc which the previous two did not.\n  Things get even more complication in the presence of callbacks. If in the callback you supply to library A, you call library B, you may need to insert switch statement maps or other mechanisms to convert library B\u0026rsquo;s failures into something library A can understand, and then somehow extract that out \u0026ndash; preferably without loss of original information \u0026ndash; into the application\u0026rsquo;s failure handling mechanism if library A subsequently returns failure as well. This implies transmitting state by which to track these interrelated pieces of failure data.\nLet us see what Outcome can do to help the application writer address some of these issues, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/value-or-error/",
	"title": "ValueOrError Concept",
	"tags": ["value-or-error"],
	"description": "",
	"content": " Something not really mentioned until now is how Outcome interoperates with the proposed std::expected\u0026lt;T, E\u0026gt;, whose design lands in between outcome::unchecked\u0026lt;T, E\u0026gt; and outcome::checked\u0026lt;T, E\u0026gt;, both of which are simplified aliases for outcome::result\u0026lt;T, E\u0026gt; hard coding the NoValuePolicy to a fixed policy.\nExpected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.\nOutcome\u0026rsquo;s result\u0026lt;X, Y\u0026gt; will explicitly construct from any type matching the ValueOrError concept, which includes std::expected\u0026lt;A, B\u0026gt;, if A is constructible to X and B is constructible to Y. The ValueOrError concept in turn is true if and only if the input type has:\n A value_type and error_type member typedefs. A .has_value() observer returning a bool. .value() and .error() observers.  Implementation Outcome\u0026rsquo;s machinery for implementing ValueOrError conversion is user extensible by injection of specialisations of the value_or_error\u0026lt;DEST, SRC\u0026gt; type into the OUTCOME_V2_NAMESPACE::convert namespace.\nOutcome\u0026rsquo;s default convert::value_or_error\u0026lt;DEST, SRC\u0026gt; implementation explicitly excludes Outcome result and outcome types from the default mechanism as there is a major gotcha: Outcome\u0026rsquo;s .value() is often not callable in constexpr as it can throw, which makes this mechanism pretty much useless for constexpr code. Thus separate explicit converting constructors exist which constexpr convert from any Outcome type (though note that result construction from outcome does use the ValueOrError mechanism).\nExamples of how to implement your own convert::value_or_error\u0026lt;DEST, SRC\u0026gt; converter is demonstrated in the worked example, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/",
	"title": "Motivation",
	"tags": [],
	"description": "",
	"content": "This section describes techniques currently used to report and handle failures in functions, it also shows why this techniques might be insufficient.\nIf you just want to learn how to use Outcome library go straight to Tutorial section.\nMotivation section of this documentation is not complete yet.\n  Exceptions Exceptions with their good and bad sides.\n errno errno with their good and bad sides.\n Error codes Error codes with their good and bad sides.\n std::error_code Overview of std::error_code\n Plugging a library into std::error_code Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.\n Narrow contracts Describes narrow-contract functions that do not work for all input values, and advantage of using them.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/no-value/custom/",
	"title": "A custom no-value policy",
	"tags": [],
	"description": "",
	"content": "If you want your basic_outcome\u0026lt;\u0026gt; or basic_result\u0026lt;\u0026gt; instances to call std::abort() whenever .value() is called on an object that does not contain a value, or .error() is called on an object that does not contain an error, you will need to define your own no-value policy as follows:\nstruct abort_policy : outcome::policy::base { template \u0026lt;classImpl\u0026gt; static constexpr void wide_value_check(const Impl\u0026amp; self) { if (!base::_has_value(self)) std::abort(); } template \u0026lt;classImpl\u0026gt; static constexpr void wide_error_check(const Impl\u0026amp; self) { if (!base::_has_error(self)) std::abort(); } template \u0026lt;classImpl\u0026gt; static constexpr void wide_exception_check(const Impl\u0026amp; self) { if (!base::_has_exception(self)) std::abort(); } }; View this code on Github Once the policy is defined, you have to use it when providing your own basic_outcome specialization:\ntemplate \u0026lt;typename T\u0026gt; using strictOutcome = outcome::basic_outcome\u0026lt;T, std::error_code, std::exception_ptr, abort_policy\u0026gt;; View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/motivation/exceptions/",
	"title": "Exceptions",
	"tags": [],
	"description": "Exceptions with their good and bad sides.",
	"content": " Exceptions Exceptions are the default mechanism in C++ for reporting, propagating and processing the information about function failures. Their main advantage is the ability to describe the \u0026ldquo;success dependency\u0026rdquo; between functions: if you want to say that calling function g() depends on the successful execution of function f(), you just put g() below f() and that\u0026rsquo;s it:\nint a() { f(); g(); // don\u0026#39;t call g() and further if f() fails  return h(); // don\u0026#39;t call h() if g() fails }  In the C++ Standard terms this means that f() is sequenced before g(). This makes failure handling extremely easy: in a lot of cases you do not have to do anything.\nAlso, while next operations are being canceled, the exception object containing the information about the initial failure is kept on the side. When at some point the cancellation cascade is stopped by an exception handler, the exception object can be inspected. It can contain arbitrarily big amount of data about the failure reason, including the entire call stack.\nDownsides There are two kinds of overheads caused by the exception handling mechanism. The first is connected with storing the exceptions on the side. Stack unwinding works independently in each thread of execution; each thread can be potentially handling a number of exceptions (even though only one exception can be active in one thread). This requires being prepared for storing an arbitrary number of exceptions of arbitrary types per thread. Additional things like jump tables also need to be stored in the program binaries.\nSecond overhead is experienced when throwing an exception and trying to find the handler. Since nearly any function can throw an exception of any time, this is a dynamic memory allocation. The type of an exception is erased an a run-time type identification (RTTI) is required to asses the type of the active exception object. The worse time required for matching exceptions against handlers cannot be easily predicted and therefore exceptions are not suitable for real-time or low-latency systems.\nAnother problem connected with exceptions is that while they are good for program flows with linear \u0026ldquo;success dependency\u0026rdquo;, they become inconvenient in situations where this success dependency does not occur. One such notable example is releasing acquired resources which needs to be performed even if previous operations have failed. Another example is when some function c() depends on the success of at least one of two functions a() and b() (which try, for instance, to store user data by two different means), another example is when implementing a strong exception safety guarantee we may need to apply some fallback actions when previous operations have failed. When failures are reported by exceptions, the semantics of canceling all subsequent operations is a hindrance rather than help; these situations require special and non-trivial idioms to be employed.\nFor these reasons in some projects using exceptions is forbidden. Compilers offer switches to disable exceptions altogether (they refuse to compile a throw, and turn already compiled throws into calls to std::abort()).\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/keeping_state/",
	"title": "Keeping state",
	"tags": ["backtrace"],
	"description": "",
	"content": "The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result\u0026lt;T, std::pair\u0026lt;error_code, std::unique_ptr\u0026lt;stack_backtrace\u0026gt;\u0026gt;\u0026gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.\nWe therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.\n/* Outcome\u0026#39;s hook mechanism works vis ADL, so we will need a custom namespace to ensure the hooks apply only to the types declared in this namespace only */ namespace error_code_extended { // The extra error information we will keep  struct extended_error_info { std::array\u0026lt;void *, 16\u0026gt; backtrace; // The backtrace  size_t items; // Items in backtrace array which are valid  }; struct mythreadlocaldata_t { // Keep 16 slots of extended error info as a ringbuffer  extended_error_info slots[16]; // The current oldest slot  uint16_t current{0}; // Return the oldest slot  extended_error_info \u0026amp;next() { return slots[(current++) % 16]; } // Retrieve a previously stored slot, detecting if it is stale  extended_error_info *get(uint16_t idx) { // If the idx is stale, return not found  if(idx - current \u0026gt;= 16) { return nullptr; } return slots + (idx % 16); } }; // Meyers\u0026#39; singleton returning a thread local data structure for this thread  inline mythreadlocaldata_t \u0026amp;mythreadlocaldata() { static thread_local mythreadlocaldata_t v; return v; } } View this code on Github The extended error info is kept in a sixteen item long ring buffer. We continuously increment the current index pointer which is a 16 bit value which will wrap after 65,535. This lets us detect an attempt to access recycled storage, and thus return item-not-found instead of the wrong extended error info.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/limitations/",
	"title": "Limitations",
	"tags": [],
	"description": "",
	"content": "C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:\n A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should be annotated with extern \u0026quot;C\u0026quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI. You cannot use overloading in your extern \u0026quot;C\u0026quot; functions. You may only use types in your C++ function for which these traits are both true:  std::is_standard_layout_v\u0026lt;T\u0026gt; std::is_trivially_copyable_v\u0026lt;T\u0026gt; Note that std::is_trivially_copyable_v\u0026lt;T\u0026gt; also requires trivial destruction, but NOT trivial construction. This means that C++ can do non-trivial construction of otherwise trivial types.  Your C++ function should return either a result\u0026lt;T, E\u0026gt; or a result\u0026lt;T\u0026gt; i.e. with the EC defaulted to std::error_code or something with equal layout. Note that std::error_code has standard layout, and is trivially copyable, and thus is a legal type in C.  These type limitations might seem to be showstoppers to C++ programmers, but with a bit of care during library design, you can actually express a lot of complex C++ and still meet these requirements. For example, more than 80% of the APIs in my C++ 17 AFIO library (which I hope to propose in 2018 to become the File I/O TS for C++ 24) meets the above restrictions, and thus can be called directly from C code or any programming language which speaks the C ABI.\nA useful tip is to sprinkle static_assert() testing the two traits above around your header files for any types which can traverse the C ABI boundary, and add extern \u0026quot;C\u0026quot; free function thunks for your class member functions1. You should be ready to go from the C++ side at least.\n Or simply write a script to do this for you. A starter script can be found at https://github.com/ned14/afio/blob/master/scripts/make_free_functions.py. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/",
	"title": "Macros",
	"tags": [],
	"description": "",
	"content": " Constrained template macros Version macros OUTCOME_DISABLE_EXECINFO If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\n OUTCOME_NODISCARD How to tell the compiler than the return value of a function should not be discarded without examining it.\n OUTCOME_REQUIRES(...) A C++ 20 requires(...), if available.\n OUTCOME_SYMBOL_VISIBLE How to mark throwable types as always having default ELF symbol visibility.\n OUTCOME_THREAD_LOCAL How to mark variables as having thread local storage duration.\n OUTCOME_THROW_EXCEPTION(expr) How to throw a C++ exception, or equivalent thereof.\n OUTCOME_TRY(var, expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, assigning T to a variable called var if successful, immediately returning E from the calling function if unsuccessful.\n OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;void, E\u0026gt; concept, continuing execution if successful, immediately returning E from the calling function if unsuccessful.\n OUTCOME_TRYX(expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, emitting the T if successful, immediately returning E from the calling function if unsuccessful.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file/",
	"title": "The Filesystem TS",
	"tags": ["dual-api"],
	"description": "",
	"content": "Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.\nConsider the copy_file() API from the Filesystem TS:\nnamespace filesystem { /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. \\throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to); /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. If false, `ec` is written with the error code reported by the operating system. \\throws Never throws. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to, std::error_code \u0026amp;ec) noexcept; } View this code on Github Before Outcome, the common design pattern was to provide throwing and non-throwing overloads of every API. As you can see above, the throwing API throws a filesystem::filesystem_error exception type which carries additional information, specifically two paths. These paths may refer to the files which were the source of any failure. However the non-throwing overload does not provide this additional information, which can make it more annoying to use the non-throwing overload sometimes.\nWhat if we could replace these two overloads of every API in the Filesystem TS with a single API, and additionally have the non-throwing edition return the exact same additional information as the throwing edition?\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/httplib/",
	"title": "The HTTP library",
	"tags": [],
	"description": "",
	"content": "Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.\nLet us imagine that the HTTP library has the following public interface:\n// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum classstatus_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library  template \u0026lt;classT\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure\u0026gt;; /* Performs a HTTP GET on the url, returning the body if successful, a failure with status_code if unsuccessful at the HTTP level, or a C++ exception throw if something catastrophic happened e.g. bad_alloc */ result\u0026lt;std::string\u0026gt; get(std::string url); } View this code on Github The HTTP library is a mixed-failure design. Likely failures (HTTP status codes) are returned via httplib::failure, unlikely failures (e.g. out of memory) are returned via throw of the usual STL exception types.\nThe sole API we bother describing is an implementation of HTTP GET. It fetches a URL, and either returns the contents or the failure reason why not.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " result\u0026lt;\u0026gt; Gentle introduction to writing code with simple success-or-failure return types.\n Inspecting result TRY operations outcome\u0026lt;\u0026gt; Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.\n Inspecting outcome No-value policies Describes the concept of NoValuePolicy and how to use no-value policies.\n A custom no-value policy Built-in policies Custom payloads Success-or-failure return types where extra information in addition to the error code accompanies failure.\n The Filesystem TS Upgrading the Filesystem TS Auto-throwing filesystem_error Result returning constructors How to metaprogram construction of objects which use resultto return failure instead of throwing a C++ exception.\n Two phase construction A file handle Phase 2 construction Phase 3 construct Alternatives Hooking events Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.\n Keeping state ADL bridging Hook result Custom exception ptr Hook outcome Using result from C code Interacting with resultreturning C++ functions from C code.\n Limitations Example C++ function Calling it from C Variations Interoperation Interoperating with std::expectedand other ValueOrError concept matching types.\n Incommensurate E types ValueOrError Concept The HTTP library The HTMLTidy library The File I/O library The Application Mapping the HTTP library into the Application 1\u0026frasl;2 Mapping the HTTP library into the Application 2\u0026frasl;2 Mapping the File I/O library into the Application Mapping the HTMLTidy library into the Application In use Conclusion "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/two-phase-init/",
	"title": "Two phase construction",
	"tags": [],
	"description": "",
	"content": "The first thing to do is to break your object\u0026rsquo;s construction into two phases:\n Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1. If you need to initialise a member variable without a constexpr constructor, std::optional\u0026lt;T\u0026gt; is the usual workaround.\n Do the remainder of the construction, the parts which could fail. Because phase 1 placed the object into a legally destructible state, it is usually the case that one can bail out during phase 2 and the destructor will clean things up correctly.\n  The phase 1 construction will be placed into a private constexpr constructor so nobody external can call it. The phase 2 construction will be placed into a static member initialisation function which returns a result with either the successfully constructed object, or the cause of any failure to construct the object.\nFinally, as a phase 3, some simple metaprogramming will implement a construct\u0026lt;T\u0026gt;{Args...}() free function which will construct any object T by calling its static initialisation function with Args... and returning the result returned. This isn\u0026rsquo;t as nice as calling T(Args...) directly, but it\u0026rsquo;s not too bad in practice. And more importantly, it lets you write generic code which can construct any unknown object which fails via returning result, completely avoiding C++ exception throws.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/",
	"title": "result&lt;&gt;",
	"tags": ["result", "try", "namespace"],
	"description": "Gentle introduction to writing code with simple success-or-failure return types.",
	"content": " Outcome 2.0 namespace It is recommended that you refer to entities from this Outcome 2.0 via the following namespace alias:\nnamespace outcome = OUTCOME_V2_NAMESPACE; View this code on Github As patches and modifications are applied to this library, namespaces get permuted in order not to break any backward compatibility. At some point namespace outcome::v2 will be defined, and this will be the prefered namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome::v2.\nCreating result\u0026lt;\u0026gt; We will define a function that converts an std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept; View this code on Github Class template API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__result-R-S-NoValuePolicy- has three template parameters, but the last two have default values. The first (T) represents the type of the object returned from the function upon success. The second (EC) is the type of object containing information about the reason for failure when the function fails. A result object stores either a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code. The third parameter (NVP) is called a no-value policy. We will cover it later.\nIf both T and EC are trivially copyable, result\u0026lt;T, EC, NVP\u0026gt; is also trivially copyable.\nNow, we will define an enumeration describing different failure situations during conversion.\nenum classConversionErrc { Success = 0, // 0 should not represent an error  EmptyString = 1, // (for rationale, see tutorial on error codes)  IllegalChar = 2, TooLong = 3, }; // all boilerplate necessary to plug ConversionErrc // into std::error_code framework View this code on Github Assume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() \u0026gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); } View this code on Github result\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that there is no constructability possible in either direction between T and EC. If there is, all implicit conversion is disabled, and you will need to use one of the tagged constructors:\noutcome::result\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString}; outcome::result\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1}; View this code on Github Or use helper factory functions:\noutcome::result\u0026lt;int\u0026gt; r = outcome::failure(ConversionErrc::EmptyString); outcome::result\u0026lt;int\u0026gt; s = outcome::success(1); View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/tidylib/",
	"title": "The HTMLTidy library",
	"tags": [],
	"description": "",
	"content": "// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool, I highly recommend it.  // This isn\u0026#39;t the API for Tidy, but let\u0026#39;s assume it\u0026#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern \u0026#34;C\u0026#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a \u0026ldquo;split\u0026rdquo; T|E API. The above is an example of exactly that form of \u0026ldquo;split\u0026rdquo; T|E API.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/file_handle/",
	"title": "A file handle",
	"tags": [],
	"description": "",
	"content": "Borrowing from afio::file_handle which uses this design pattern, here is a simplified file_handle implementation:\nclassfile_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum classmode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!\u0026lt; No ability to read or write anything, but can synchronise (SYNCHRONIZE or 0)  attr_read = 4, //!\u0026lt; Ability to read attributes (FILE_READ_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  attr_write = 5, //!\u0026lt; Ability to read and write attributes (FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  read = 6, //!\u0026lt; Ability to read (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONISE or O_RDONLY)  write = 7, //!\u0026lt; Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONISE or O_RDWR)  append = 9 //!\u0026lt; All mainstream OSs and CIFS guarantee this is atomic with respect to all other appenders (FILE_APPEND_DATA|SYNCHRONISE or O_APPEND)  }; // Moves but not copies permitted  file_handle(const file_handle \u0026amp;) = delete; file_handle(file_handle \u0026amp;\u0026amp;o) noexcept : _fd(o._fd) { o._fd = -1; } file_handle \u0026amp;operator=(const file_handle \u0026amp;) = delete; file_handle \u0026amp;operator=(file_handle \u0026amp;\u0026amp;o) noexcept { this-\u0026gt;~file_handle(); new(this) file_handle(std::move(o)); return *this; } // Destruction closes the handle  ~file_handle() { if(_fd != -1) { if(-1 == ::close(_fd)) { int e = errno; std::cerr \u0026lt;\u0026lt; \u0026#34;FATAL: Closing the fd during destruction failed due to \u0026#34; \u0026lt;\u0026lt; strerror(e) \u0026lt;\u0026lt; std::endl; std::terminate(); } _fd = -1; } } // Phase 2 static member constructor function, which cannot throw  static inline outcome::result\u0026lt;file_handle\u0026gt; file(path_type path, mode mode = mode::read) noexcept; }; View this code on Github Note the default member initialisers, these are particularly convenient for implementing phase 1 of construction. Note also the constexpr constructor, which thanks to the default member initialisers is otherwise empty.\nFile handles are very expensive to copy as they involve a syscall to duplicate the file descriptor, so we enable moves only.\nThe destructor closes the file descriptor if it is not -1, and if the close fails, seeing as there is nothing else we can do without leaking the file descriptor, we fatal exit the process.\nFinally we declare the phase 2 constructor which is a static member function.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/",
	"title": "ADL bridging",
	"tags": ["adl-bridging"],
	"description": "",
	"content": "In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered API NOT FOUND IN DOCS success_failure/#standardese-outcome_v2_xxx__policy__throw_as_system_error_with_payload-Error--Errorconst-- function was to be found.\nHere we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.\nnamespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn\u0026#39;t trigger the ADL bridge.  struct error_code : public std::error_code { // literally passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise result and outcome to using the local error_code so this namespace gets looked up for the hooks  template \u0026lt;classR\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;R, error_code\u0026gt;; template \u0026lt;classR\u0026gt; using outcome = OUTCOME_V2_NAMESPACE::outcome\u0026lt;R, error_code /*, std::exception_ptr */\u0026gt;; } View this code on Github For convenience, we template alias local copies of result and outcome in this namespace bound to the ADL bridging error_code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " Macros Constrained template macros Version macros OUTCOME_DISABLE_EXECINFO If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\n OUTCOME_NODISCARD How to tell the compiler than the return value of a function should not be discarded without examining it.\n OUTCOME_REQUIRES(...) A C++ 20 requires(...), if available.\n OUTCOME_SYMBOL_VISIBLE How to mark throwable types as always having default ELF symbol visibility.\n OUTCOME_THREAD_LOCAL How to mark variables as having thread local storage duration.\n OUTCOME_THROW_EXCEPTION(expr) How to throw a C++ exception, or equivalent thereof.\n OUTCOME_TRY(var, expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, assigning T to a variable called var if successful, immediately returning E from the calling function if unsuccessful.\n OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;void, E\u0026gt; concept, continuing execution if successful, immediately returning E from the calling function if unsuccessful.\n OUTCOME_TRYX(expr) Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, emitting the T if successful, immediately returning E from the calling function if unsuccessful.\n Concepts ValueOrError\u0026lt;T, E\u0026gt; A boolean concept matching types with either a value or an error.\n ValueOrNone\u0026lt;T\u0026gt; A boolean concept matching types with an optional value.\n Converters try_operation_return_as(expr) A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types to a returnable failure type.\n value_or_error\u0026lt;T, U\u0026gt; A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types.\n Traits has_error_code\u0026lt;T\u0026gt; True if an error code can be constructed from a T.\n has_exception_ptr\u0026lt;T\u0026gt; True if an exception ptr can be constructed from a T.\n is_basic_result\u0026lt;T\u0026gt; An integral constant type true for `basic_resulttypes.\n is_error_type\u0026lt;E\u0026gt; A customisable integral constant type true for E types which are to receive error throwing no-value policies.\n is_error_type_enum\u0026lt;E, Enum\u0026gt; A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies.\n type_can_be_used_in_basic_result\u0026lt;R\u0026gt; A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n Policies Types basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; A sum type carrying either a successful T, or a disappointment E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n in_place_type_t\u0026lt;T\u0026gt; Either std::in_place_type_t\u0026lt;T\u0026gt; if C++ 17 or later, else a local emulation.\n Aliases Functions Traits "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/no-value/builtin/",
	"title": "Built-in policies",
	"tags": [],
	"description": "",
	"content": "These are the predefined policies built into Outcome:\nAPI NOT FOUND IN DOCS policies/all_narrow If there is an observation of a value/error/exception which is not present, the behavior is undefined. However this is a tool-friendly UB using intrinsics such as __builtin_unreachable() that allows tool to make use of it, e.g., better bug detection or optimizations.\nAPI NOT FOUND IN DOCS policies/terminate Observation of a missing value/error/exception causes the call to std::terminate().\nAPI NOT FOUND IN DOCS policies/outcome_error_code_throw_as_system_error This policy assumes that EC has the interface of std::error_code, and EP has the interface of std::exception_ptr. Upon missing value observation:\n if an exception is stored through pointer of type EP it is rethrown; otherwise, if an error of type EC is stored, it is converted to error_code and then thrown as system_error.  Upon missing error observation throws:\n bad_result_access(\u0026quot;no error\u0026quot;) from instances of basic_result\u0026lt;\u0026gt;. bad_outcome_access(\u0026quot;no error\u0026quot;) from instances of basic_outcome\u0026lt;\u0026gt;.  Upon missing exception observation throws bad_outcome_access(\u0026quot;no exception\u0026quot;).\nAPI NOT FOUND IN DOCS policies/outcome_exception_ptr_rethrow This policy assumes that both EC and EP (unless void) has the interface of std::exception_ptr. Upon missing value observation:\n in instances of basic_result\u0026lt;\u0026gt;, rethrows exception pointed to by EC; in instances of basic_outcome\u0026lt;\u0026gt;, if exception ep is present rethrows it, otherwise rethrows the stored error.  Upon missing error observation:\n in instances of basic_result\u0026lt;\u0026gt;, throws bad_result_access(\u0026quot;no error\u0026quot;) ; in instances of basic_outcome\u0026lt;\u0026gt;, throws bad_outcome_access(\u0026quot;no error\u0026quot;).  Upon missing exception observation throws bad_outcome_access(\u0026quot;no exception\u0026quot;).\nAPI NOT FOUND IN DOCS policies/throw_bad_result_access Upon missing value observation throws bad_result_access_with\u0026lt;EC\u0026gt;(ec), where ec is the value of the stored error. If error is not stored, the behavior is undefined.\nUpon missing error observation throws bad_result_access(\u0026quot;no error\u0026quot;).\nThis policy should not be used with basic_outcome\u0026lt;\u0026gt; instances.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " ValueOrError\u0026lt;T, E\u0026gt; A boolean concept matching types with either a value or an error.\n ValueOrNone\u0026lt;T\u0026gt; A boolean concept matching types with an optional value.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/example/",
	"title": "Example C++ function",
	"tags": [],
	"description": "",
	"content": "Let us start with a simple C++ function which we wish to make available to C code:\n// Fill the supplied buffer with the integer v converted to a string, returning // length of string minus null terminator extern \u0026#34;C\u0026#34; outcome::result\u0026lt;size_t\u0026gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.size() + 1 \u0026gt; bufferlen) return std::errc::no_buffer_space; // Copy the string into the supplied buffer, and return length of string  memcpy(buffer, temp.data(), temp.size() + 1); return temp.size(); } catch(...) { // This utility function rethrows the C++ exception, matching it  // against every standard library exception and generating an  // error code exactly matching it if possible. So, if the  // string creation threw std::bad_alloc, that would be converted  // into make_error_code(std::errc::not_enough_memory).  return outcome::error_from_exception(); } } View this code on Github A surprise to some may be that one can return an outcome::result\u0026lt;size_t\u0026gt; from a C function! This is because if for some result\u0026lt;T, EC\u0026gt; where both T and EC have standard layout and are trivially copyable, then Outcome guarantees so will result\u0026lt;T, EC\u0026gt;. Thus outcome::result\u0026lt;size_t\u0026gt; is a perfectly legal C type, and can be returned directly to C code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/inspecting/",
	"title": "Inspecting result&lt;T, EC&gt;",
	"tags": ["nodiscard", "value", "error", "try"],
	"description": "",
	"content": "Suppose we will be writing a function print_half that takes an integer number (however big) represented as an std::string and outputs a number which is twice smaller:\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text); View this code on Github The type result\u0026lt;void\u0026gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result\u0026lt;\u0026gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represented by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use the function convert defined in the previous section.\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text) { if (outcome::result\u0026lt;int\u0026gt; r = convert(text)) // #1  { std::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2  } else { if (r.error() == ConversionErrc::TooLong) // #3  { OUTCOME_TRY (i, BigInt::fromString(text)); // #4  std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl; } else { return r.as_failure(); // #5  } } return outcome::success(); // #6 } View this code on Github #1. You test if result\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. The function .value() extracts the successfully returned int.\n#3. The function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the expression in the second argument returns a result\u0026lt;\u0026gt;. The function is defined as:\n/*static*/ outcome::result\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s) View this code on Github Our control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of result\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type BigInt with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type BigInt is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but r.as_failure() will work when implicit construction from E has been disabled due to T and E having a constructibility relationship.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/filelib/",
	"title": "The File I/O library",
	"tags": [],
	"description": "",
	"content": "The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:\n// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Tell Outcome that no-value observation should throw a custom exception  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing copy_file() edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec); } // Localise a result implementation specific to this namespace.  template \u0026lt;classT\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure_info\u0026gt;; // Writes a chunk of data to some file. Returns bytes written, or failure_info. Never throws exceptions.  result\u0026lt;size_t\u0026gt; write_file(string_view chunk) noexcept; } View this code on Github This uses the advanced Outcome feature of programming the lazy synthesis of custom C++ exception throws from a payload carrying E type called failure_info. Like the HTTP library, it too template aliases a localised result implementation into its namespace with ADL bridging so Outcome customisation points can be discovered.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file2/",
	"title": "Upgrading the Filesystem TS",
	"tags": ["payload"],
	"description": "",
	"content": "An Outcome based solution to the dual overload problem is straightforward:\nnamespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace. Normally would just  // be `result`, but for clarity we\u0026#39;ll use `fs_result`.  template \u0026lt;classT\u0026gt; using fs_result = outcome::result\u0026lt;T, failure_info\u0026gt;; /*! Copies the file at path `from` to path `to`. \\returns Successful if file was successfully copied, otherwise the error code reported by the operating system plus a payload of the paths involved. \\throws Never throws. */ fs_result\u0026lt;void\u0026gt; copy_file(const path \u0026amp;from, const path \u0026amp;to) noexcept; } View this code on Github Starting at the bottom, there is now a single copy_file() function which returns a fs_result\u0026lt;void\u0026gt;. As result is either successful or not, there is no longer any point in returning a boolean, so we simply return void on success. On failure, as the template alias fs_result\u0026lt;T\u0026gt; above it shows, we are returning a failure_info structure containing an error code and the same additional information as filesystem_error provides.\nIt is important to note that the fact that failure_info is defined in namespace filesystem2 is very important. This is because Outcome uses Argument Dependent Lookup (ADL) to find the make_error_code() function, as well as other customisation point free functions. In other words, only the namespaces as defined by ADL are searched when finding a free function telling us what to do for failure_info, which includes the namespace failure_info is declared into.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/errno/",
	"title": "errno",
	"tags": [],
	"description": "errno with their good and bad sides.",
	"content": " errno The idiom of returning, upon failure, a special value and storing an error code (an int) inside a global (or thread-local) object errno is inherited from C, and used in its Standard Library:\nint readValue(const char * filename) { FILE* f = fopen(filename, \u0026#34;r\u0026#34;); if (f == NULL) return 0; // special value indicating failure  // keep errno value set by fopen()  int i; int r = fscanf(f, \u0026#34;%d\u0026#34;, \u0026amp;i); if (r == 0 || r == EOF) { // special values: i not read  errno = ENODATA; // choose error value to return  return 0; fclose(f); errno = 0; // clear error info (success)  return i; }  One advantage (to some and a disadvantage to others) of this technique is that it uses familiar control statements (if and return) to indicate all execution paths that handle failures. When we read this code we know when and under what conditions it can exit without producing the expected result.\nDownsides Because on failure, as well as success, we write into a global (or thread-local) object, our functions are not pure: they have side effects. This means many useful compiler optimizations (like common subexpression elimination) cannot be applied. This chows that it is not only C++ that chooses suboptimal solutions for reporting failures.\nWhatever type we return, we always need a special value to spare, which is sometimes troublesome. In the above example, if the successfully read value of i is 0, and we return it, our callers will think it is a failure even though it is not.\nError propagation using if statements and early returns is manual. We can easily forget to check for the failure, and incorrectly let the subsequent operations execute, potentially causing damage to the program state.\nUpon nearly each function call layer we may have to change error code value so that it reflects the error condition adequate to the current layer. If we do so, the original error code is gone.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/",
	"title": "outcome&lt;&gt;",
	"tags": ["outcome"],
	"description": "Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.",
	"content": " outcome\u0026lt;\u0026gt; Type API NOT FOUND IN DOCS outcome/#standardese-outcome_v2_xxx__outcome-R-S-P-NoValuePolicy- represets either a successfully computed value of type T or a reason for failure. Failure can be represented by EC or EP or both. Although usually it will either be an EC or an EP. EC defaults to std::error_code and EP defaults to std::exception_ptr. The distinction is made into two types, EC and EP:\n EC represents a failue from lower-layer function which was retured through API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__result-R-S-NoValuePolicy-. EP represents pointer to an exception thrown in a lower-layer function to signal a failure; but at the current level we do not want to proceed with stack unwinding.  outcome is useful for transporting exceptions across layers of the program that were never designed with exception safety in mind.\nConsider a program consisting of three layers:\nmermaid.initialize({startOnLoad:true}); graph BT L3[\"Layer3\"] L2[\"Layer2_old\"] -- L3 L1[\"Layer1\"] -- L2  The highest-level layer, Layer3, uses exceptions for signalling failures. The middle layer, Layer2_old, was not designed with exception safety in mind and functions need to return information about failures in return value. But down in the implementation details, in Layer1, another library is used that again throws exceptions. The goal is to be able to transfer an exception thrown in Layer1 through Layer2_old, which is not exception-safe, and be able to rethrow it in Layer3.\nIn Layer1 we have two functions from two libraries: one reports failures by throwing exceptions, the other by returning result\u0026lt;\u0026gt;:\nauto f() -\u0026gt; int; // throws on failure auto g() noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;; View this code on Github In Layer2_old we cannot use exceptions, so its function h uses return type outcome\u0026lt;\u0026gt; to report failures. It is using functions f and g and reports their failures inside outcome\u0026lt;\u0026gt;:\nauto old::h() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; { OUTCOME_TRY(i, (g())); // #1  try { return i + f(); } catch (...) { return std::current_exception(); // #2  } } View this code on Github #1. Operator TRY can forward failures encoded in result\u0026lt;T, EC\u0026gt; as outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information. You can also use TRY to forward failure from one outcome\u0026lt;\u0026gt; to another.\n#2. You can store the current exception through std::exception_ptr inside outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information (provided that EP is std::exception_ptr).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/converters/",
	"title": "Converters",
	"tags": [],
	"description": "",
	"content": " try_operation_return_as(expr) A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types to a returnable failure type.\n value_or_error\u0026lt;T, U\u0026gt; A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/no-value/",
	"title": "No-value policies",
	"tags": ["policies"],
	"description": "Describes the concept of NoValuePolicy and how to use no-value policies.",
	"content": "In the previous section we have seen that calling member function .value() on object of type outcome\u0026lt;T\u0026gt; that did not contain a value caused an exception to be thrown. This is only part of the story. The full semantics of member function .value() are a bit more complex.\nLet\u0026rsquo;s consider result\u0026lt;T\u0026gt; first. It is an alias on basic_result\u0026lt;T, EC, NVP\u0026gt;, where EC is the type storing error information and defaulted to std::error_code and NVP is a no-value policy and defaulted to policy::default_policy\u0026lt;T, EC, void\u0026gt;.\nThe semantics of basic_result::value() are:\n Calls NVP::wide_value_check(*this). If this-\u0026gt;has_value() == true then returns a reference to the contained value, otherwise the behavior is undefined.  Thus, the semantics of function .value() depend on the no-value policy. The default policy (policy::default_policy\u0026lt;T, EC, void\u0026gt;) for EC of type std::error_code does the following:\n If r.has_value() == false throws exception std::system_error{r.error()}, otherwise no effect.  Class templates basic_result\u0026lt;T, EC, NVP\u0026gt; and basic_outcome\u0026lt;T, EC, EP, NVP\u0026gt; never use exceptions. Any exception-related logic is provided through no-value policies.\n When designing your own success-or-failure type using templates basic_result\u0026lt;\u0026gt; or basic_outcome\u0026lt;\u0026gt; you have to decide what no-value policy you want to use. Either create your own, or use one of the predefined policies.\nYou can also use two predefined aliases for basic_result\u0026lt;\u0026gt;:\n  API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__unchecked-R-S-: it uses policy API NOT FOUND IN DOCS policies/all_narrow, where any observation of a missing value or error is undefined behavior;  API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__checked-R-S-: it uses policy API NOT FOUND IN DOCS policies/throw_bad_result_access, where any observation of a missing value or error throws API NOT FOUND IN DOCS bad_access/#standardese-outcome_v2_xxx__bad_result_access_with-S- or API NOT FOUND IN DOCS bad_access/#standardese-outcome_v2_xxx__bad_result_access respectively.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app/",
	"title": "The Application",
	"tags": [],
	"description": "",
	"content": "The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.\n// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template \u0026lt;classT\u0026gt; using outcome = OUTCOME_V2_NAMESPACE::outcome\u0026lt;T, error_code /*, std::exception_ptr */\u0026gt;; using OUTCOME_V2_NAMESPACE::success; } View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.\nThe way we are going to configure interop is as follows:\n The application shall use error_code for anticipated failure and C++ exception throws for unanticipated failure. We shall choose the convention that app::outcome with exception ptr solely and exclusively represents a type erased failure from a third party library.  Thus if one calls .value() on an app::outcome, both anticipated failure within the app and type erased failure from a third party library shall be converted to a C++ exception throw.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file3/",
	"title": "Auto-throwing filesystem_error",
	"tags": ["default-actions", "value"],
	"description": "",
	"content": "Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.\nSeeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.\nTelling Outcome how to throw a filesystem_error with payload of the failing paths is easy:\nnamespace filesystem2 { // If we would like Outcome to do something other than the default action (see next  // section), we can declare this ADL discovered free function to customise what  // to do instead.  //  // Note that rvalue semantics are propagated internally by Outcome, so if the user  // called .value() on a rvalued result, failure_info will be moved rather than  // copied from the result. That means we can overload once with value semantics,  // and not need to overload for lvalue and rvalue situations unless we really feel  // we need to for some reason.  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.  outcome::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing copy_file() edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec); } } View this code on Github Usage of our new \u0026ldquo;upgraded\u0026rdquo; Filesystem copy_file() might now be as follows:\n// Non-throwing use case  auto o = filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;); if(!o) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with error \u0026#34; \u0026lt;\u0026lt; o.error().ec.message() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; o.error().path1 \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; o.error().path2 \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } // Throwing use case  try { // Try to observe the successful value, thus triggering default actions which invokes  // our outcome_throw_as_system_error_with_payload() above which then throws filesystem_error  // exactly like the Filesystem TS does for its throwing overload.  filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;).value(); } catch(const filesystem2::filesystem_error \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; e.path2() \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; std::endl; } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/example2/",
	"title": "Calling it from C",
	"tags": [],
	"description": "",
	"content": "Now let us call our result returning C++ function from C:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; // for strerror// This header in Outcome is pure C, it provides a suite of C helper macros #include \u0026#34;../../../include/outcome/result.h\u0026#34; // Declare our C++ function\u0026#39;s returning result type. Only needs to be done once. CXX_DECLARE_RESULT_EC(size_t, size_t); // Tell C about our C++ function extern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v); void print(int v) { char buffer[4]; CXX_RESULT_EC(size_t) res; res = to_string(buffer, sizeof(buffer), v); if(CXX_RESULT_HAS_VALUE(res)) { printf(\u0026#34;to_string(%d) fills buffer with \u0026#39;%s\u0026#39; of %zu characters\\n\u0026#34;, v, buffer, res.value); return; } // Is the error returned in the std::generic_category domain and thus an errno?  if(CXX_RESULT_ERROR_IS_ERRNO(res)) { // If you get a weird compile error here, note that CXX_RESULT_ERROR()  // uses C11 generics, you need a C11 compiler for it to work. If you don\u0026#39;t  // have a C11 compiler, res.error or res.error.code can be used directly.  fprintf(stderr, \u0026#34;to_string(%d) failed with error code %d (%s)\\n\u0026#34;, v, CXX_RESULT_ERROR(res), strerror(CXX_RESULT_ERROR(res))); return; } fprintf(stderr, \u0026#34;to_string(%d) failed with unknown error code %d\\n\u0026#34;, v, CXX_RESULT_ERROR(res)); } int main(void) { print(9); print(99); print(999); print(9999); return 0; } View this code on Github Running this C program yields:\nto_string(9) fills buffer with '9' of 1 characters to_string(99) fills buffer with '99' of 2 characters to_string(999) fills buffer with '999' of 3 characters to_string(9999) failed with error code 105 (No buffer space available)  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/",
	"title": "Custom payloads",
	"tags": ["payload", "has_error_code", "make_error_code"],
	"description": "Success-or-failure return types where extra information in addition to the error code accompanies failure.",
	"content": "So far in this tutorial, type EC in result\u0026lt;T, EC\u0026gt; has always been a std::error_code (though it can be of any type you wish instead). EC needs in fact to merely satisfy API NOT FOUND IN DOCS success_failure/#standardese-outcome_v2_xxx__trait__has_error_code-T- for EC to be treated as if an std::error_code.\nIn turn, trait::has_error_code_v\u0026lt;EC\u0026gt; is true if there exists some ADL discovered free function:\n make_error_code(EC) returning a std::error_code. make_error_code(get\u0026lt;0\u0026gt;(EC)) returning a std::error_code (i.e. EC might be pair\u0026lt;std::error_code, U\u0026gt; or tuple\u0026lt;std::error_code, ...\u0026gt;).  \u0026hellip; or if EC is implicitly convertible into a std::error_code.\nThus, we can in fact use any custom EC type we like, including one carrying additional information, or payload. This payload can carry anything you like, and you can tell Outcome to do various things with that payload under various circumstances. For example:\n If the user tries to observe an unsuccessful result, throw a custom exception containing the cause of failure with accompanying context from the payload. If the user ever constructs an outcome from a payload carrying result, set the exception ptr in the constructed outcome to a custom exception containing the cause of the failure with accompanying context from the payload. Transmit a stack backtrace specifying the exact point at which failure occurred, symbolising that backtrace into human readable text at the moment of conversion into human readable text. Upon a namespace-localised result from library A being copy/moved into a namespace-localised result from C bindings library B, set the C errno if the error code and category map onto the errno domain.  There are many, many other options of course. This tutorial can only cover a reasonable subset. This section covers Example 1 above, throwing custom exceptions with payload upon observation of an unsuccessful result.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/error_codes/",
	"title": "Error codes",
	"tags": [],
	"description": "Error codes with their good and bad sides.",
	"content": " Error codes Error codes are reasonable error handling technique, also working in C. In this case the information is also stored as an int, but returned by value, which makes it possible to make functions pure (side-effect-free and referentially transparent).\nint readInt(const char * filename, int\u0026amp; val) { FILE* fd; int r = openFile(filename, /*out*/ fd); if (r != 0) return r; // return whatever error openFile() returned  r = readInt(fd, /*out*/ val); if (r != 0) return READERRC_NOINT; // my error code  return 0; // success }  Because the type of the error information (int) is known statically, no memory allocation or type erasure is required. This technique is very efficient.\nDownsides All failure paths written manually can be considered both an advantage and a disadvantage. Forgetting to put a failure handling if causes bugs.\nIf I need to substitute an error code returned by lower-level function with mine more appropriate at this level, the information about the original failure is gone.\nAlso, all possible error codes invented by different programmers in different third party libraries must fit into one int and not overlap with any other error code value. This is quite impossible and does not scale well.\nBecause errors are communicated through returned values, we cannot use function\u0026rsquo;s return type to return computed values. Computed values are written to function output parameters, which requires objects to be created before we have values to put into them. This requires many objects in unintended state to exist. writing to output parameters often requires an indirection and can incur some run-time cost.\n"
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "    Can I use Outcome to write zero overhead deterministic exceptions as is proposed to enter C++ 23? Is Outcome safe to use in extern APIs? Does Outcome have a stable ABI and API? Why two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt; rather than just one? How badly will including Outcome in my public interface affect compile times? Is Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? What kind of performance benefits will using Outcome in my code bring? Why is implicit default construction disabled? How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design?    Can I use Outcome to write zero overhead deterministic exceptions as is proposed to enter C++ 23? Technically yes:\n// Switch this to 0 if you have deterministic exceptions support in your compiler #define OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION 1  #include \u0026#34;outcome/try.hpp\u0026#34;#include \u0026#34;outcome/experimental/status_result.hpp\u0026#34; /*! Declare an API which throws a deterministic exception. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROWS_API(rettype, errtype, ...) ::OUTCOME_V2_NAMESPACE::experimental::erased_result\u0026lt;rettype, errtype\u0026gt; __VA_ARGS__ noexcept #else #define OUTCOME_THROWS_API(rettype, errtype, ...) rettype __VA_ARGS__ throws(errtype) #endif  /*! Declare an API which deterministically throws the default std::error. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROWS_ERROR_API(rettype, ...) ::OUTCOME_V2_NAMESPACE::experimental::erased_result\u0026lt;rettype, ::SYSTEM_ERROR2_NAMESPACE::error\u0026gt; __VA_ARGS__ noexcept #else #define OUTCOME_THROWS_ERROR_API(rettype, ...) rettype __VA_ARGS__ throws(std::error) #endif  /*! Throws a deterministic exception. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROW(...) return ::OUTCOME_V2_NAMESPACE::failure(__VA_ARGS__) #else #define OUTCOME_THROW(...) throw(__VA_ARGS__) #endif  /*! Call an API. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_CALL_API(...) OUTCOME_TRY(...) #else #define OUTCOME_CALL_API(...) (__VA_ARGS__) #endif  /*! Catch any deterministic exceptions thrown by an expression into a ValueOrError concept matching type. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_CATCH_EXPR(...) (...) #else #define OUTCOME_CATCH_EXPR(...) catch(__VA_ARGS__) #endif  You would then have to write your code in this quite unnatural form:\n// Throws ::SYSTEM_ERROR2_NAMESPACE::error, the proposed std::error for P0709 Zero // overhead deterministic exceptions OUTCOME_THROWS_ERROR_API(int, foo(double x)) { if(x \u0026lt; INT_MIN || x \u0026gt; INT_MAX) OUTCOME_THROW(::SYSTEM_ERROR2_NAMESPACE::errc::result_out_of_range); return static_cast\u0026lt;int\u0026gt;(x); } ... int v = OUTCOME_CALL_API(foo(5.0));  As much as it is technically feasible, it is probably not worth inudating your C++ code with so many macros, especially as Outcome will continue to work just fine in future C++ compilers.\nIs Outcome safe to use in extern APIs? Outcome is specifically designed for use in the public interfaces of multi-million line codebases. Its layout is hard coded to:\nstruct { T value; unsigned int flags; EC error; }; This is, of course, C-compatible and Outcome provides a macro-based C interface for C code needing to call extern \u0026quot;C\u0026quot; C++ functions returning a result\u0026lt;T, EC\u0026gt;.\nDoes Outcome have a stable ABI and API? Until Outcome passes a second Boost peer review and enters Boost, no. Once into Boost, Outcome\u0026rsquo;s ABI and API will be formally fixed as the v2 interface one year after its first Boost release. Thereafter the ABI compliance checker will be run per-commit to ensure Outcome\u0026rsquo;s ABI and API remains stable.\nNote that the stable ABI and API guarantee will only apply to standalone Outcome, not to Boost.Outcome. Boost.Outcome has dependencies on other parts of Boost which are not stable across releases.\nWhy two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt; rather than just one? The two types represent slightly different things. Using two types allows expressing programmer\u0026rsquo;s intentions more directly.\nFunction signature result\u0026lt;T\u0026gt; f() noexcept means that any failures in f are exclusively reported by returning an error code.\nSimilarly, signature result\u0026lt;T\u0026gt; f() means that in addition to the above, some failures in f are signalled by throwing exceptions.\nNow, signature outcome\u0026lt;T\u0026gt; g() noexcept means that in the lower layers of the implementation we have two kinds of libraries/modules: some report failures via error codes, and some by throwing exceptions. But at the level of our interface we do not want to throw exceptions; so we forward both error codes and exceptions unaltered. The callers can easily tell which type of failure reporting was chosen, and extract it appropriately.\nAdditionally, outcome\u0026lt;T\u0026gt; can store both EC and EP at the same time. The caller of the function can choose whether to inspect the exception that provides more information and context, or to go with the error code which can be processed faster and in a more uniform way.\nThis implies that outcome\u0026lt;\u0026gt; has different interface that allows you to ask whether we are storing an exception or an error code to rethrow the stored exception but to return by value the error code, etc.\nThere is one additional possibility. When you know there will be no error codes returned \u0026ndash; only exceptions thrown, but at some layer you want to temporarily change the stack unwinding into returning failures through return values, you can use signature:\nresult\u0026lt;T, std::exception_ptr\u0026gt; f() noexcept;  How badly will including Outcome in my public interface affect compile times? Outcome is dependent on \u0026lt;system_error\u0026gt;, which unfortunately includes \u0026lt;string\u0026gt; and thus drags in quite a lot of other stuff. If your public interface already includes \u0026lt;string\u0026gt;, then the impact of including Outcome will be very low. If you do not include \u0026lt;string\u0026gt;, unfortunately impact may be relatively quite high, depending on the total impact of your public interface files.\nMeasures are being taken to remedy this situation however. The first is that C++ Modules will eliminate much of the impact of being dependent on \u0026lt;string\u0026gt;, and Outcome will make use of C++ Modules where enabled as soon as a compiler does not ICE on Outcome (i.e. Modules support is implemented specifically for the Microsoft compiler, but said compiler still internal compiler errors when attempting to create an Outcome Module. Microsoft are aware of the cause and hope to fix it within the next year or two).\nLonger term, SG14 the WG21 study group for low latency/high performance C++ are working on a \u0026lt;system_error2\u0026gt; which remedies some of the problems in \u0026lt;system_error\u0026gt;. The dependency on \u0026lt;string\u0026gt; has been removed, and thus any \u0026lt;system_error2\u0026gt; would be considerably lower impact. An Outcome v3 is likely to support any proposed \u0026lt;system_error2\u0026gt;, and that is likely many years away yet as ISO standardisation takes time.\nIs Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? Great care has been taken to ensure that Outcome never unexpectedly executes anything with unbounded execution times such as malloc(), dynamic_cast\u0026lt;\u0026gt;() or throw. Outcome works perfectly with C++ exceptions and RTTI globally disabled.\nOutcome\u0026rsquo;s entire design premise is that its users are happy to exchange a small, predictable constant overhead during successful code paths, in exchange for completely predictable failure code paths. In contrast, table-based exception handling gives zero run time overhead for the successful code path, and completely unpredictable (and very expensive) overhead for failure code paths.\nFor code where predictability of execution no matter the code path is paramount, writing all your code to use Outcome is not a bad place to start. Obviously enough, do choose a non-throwing policy when configuring outcome or result such as policy::all_narrow to guarantee that exceptions can never be thrown by Outcome (or use the convenience typedef for result, unchecked which uses policy::all_narrow).\nWhat kind of performance benefits will using Outcome in my code bring? It is very hard to say anything definitive about performance impacts in codebases one has never seen. Each codebase is unique. However to come up with some form of measure, we timed returning an error via each of the main mechanisms, doing so over ten stack frames. A stack frame is defined to be something called by the compiler whilst unwinding the stack between the point of returning the error and the thing which handles the error, so for example ten stack allocated objects might be destructed, or ten levels of stack depth might be unwound. This is not a particularly realistic test, but it should at least give one an idea of the performance impact of returning Outcome\u0026rsquo;s result or outcome over say returning a plain integer, or throwing an exception.\n  Log graph comparing GCC 7.2, clang 5.0, Visual Studio 2017.5 and XCode 8.2   As you can see, throwing and catching an exception is expensive on table-based exception handling implementations such as these, anywhere between 16,000 and 36,000 CPU cycles. Simple integer returns are always going to be the fastest as they do the least work, and that costs 90 to 100 CPU cycles.\nNote that returning a result\u0026lt;int, std::error_code\u0026gt; with an int (result-error-value) is no additional runtime overhead over returning a naked int on most compilers.\nReturning a result\u0026lt;int, std::error_code\u0026gt; with an error code (result-error-error) is no additional runtime overhead over returning a naked int on most compilers.\nYou might wonder what happens if type E has a non-trivial destructor, thus making the result\u0026lt;T, E\u0026gt; have a non-trivial destructor? We tested E = std::exception_ptr and found no performance difference to E = std::error_code for returning a value. Returning an error was obviously much slower at anywhere between 300 and 1,500 CPU cycles due to returning an exception pointer being at least two atomic operations per stack frame, but that is still two orders of magnitude better than throwing and catching an exception.\nWe conclude that if failure is anything but extremely rare in your C++ codebase, using Outcome instead of throwing and catching exceptions ought to be quicker overall.\nWhy is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome. Here are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on no-value) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on no-error). (checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers)  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; requires E to be default constructible. checked\u0026lt;T, E\u0026gt; defaults E to std::error_code. Expected does not default E.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the differing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`. It passes the reference test suite for P0323R3 at https://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications only to move the test much closer to the P0323R3 Expected, as the reference test suite is for a much older proposed Expected. Known differences from P0323R3 in this implementation: - `T` and `E` cannot be the same type. - `E` must be default constructible. - No variant storage is implemented (note the Expected proposal does not actually require this). */ namespace detail { template \u0026lt;classT, classE\u0026gt; using expected_result = OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;; template \u0026lt;classT, classE\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt; { using base = expected_result\u0026lt;T, E\u0026gt;; using base::base; constexpr enable_default_constructor() : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;} { } }; template \u0026lt;classT, classE\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;; } template \u0026lt;classT, classE\u0026gt; classexpected : public detail::select_expected_base\u0026lt;T, E\u0026gt; { static_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;); using base = detail::select_expected_base\u0026lt;T, E\u0026gt;; public: // Inherit base\u0026#39;s constructors  using base::base; expected() = default; // Expected takes in_place not in_place_type  template \u0026lt;class... Args\u0026gt; constexpr explicit expected(std::in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...} { } // Expected always accepts a T even if ambiguous  OUTCOME_TEMPLATE(classU) OUTCOME_TREQUIRES(OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value)) constexpr expected(U \u0026amp;\u0026amp;v) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)} { } // Expected has an emplace() modifier  template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; } // Expected has a narrow operator* and operator-\u0026gt;  constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); } constexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); } constexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); } constexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); } constexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); } constexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); } // Expected has a narrow error() observer  constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); } constexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); } }; template \u0026lt;classE\u0026gt; classexpected\u0026lt;void, E\u0026gt; : public OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt; { using base = OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;; public: // Inherit base constructors  using base::base; // Expected has a narrow operator* and operator-\u0026gt;  constexpr void operator*() const { base::assume_value(); } constexpr void operator-\u0026gt;() const { base::assume_value(); } }; template \u0026lt;classE\u0026gt; using unexpected = OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;; template \u0026lt;classE\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg)); } template \u0026lt;classE, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;classE\u0026gt; using bad_expected_access = OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;; View this code on Github Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design? There are a number of reasons:\n Outcome is not aimed at the same audience as Expected. We target developers and users who would be happy to use Boost. Expected targets the standard library user.\n Outcome believes that the monadic use case isn\u0026rsquo;t as important as Expected does. Specifically, we think that 99% of use of Expected in the real world will be to return failure from functions, and not as some sort of enhanced or \u0026ldquo;rich\u0026rdquo; Optional. Outcome therefore models a subset of Variant, whereas Expected models an extended Optional.\n Outcome believes that if you are thinking about using something like Outcome, then for you writing failure code will be in the same proportion as writing success code, and thus in Outcome writing for failure is exactly the same as writing for success. Expected assumes that success will be more common than failure, and makes you type more when writing for failure.\n Outcome goes to considerable effort to help the end user type fewer characters during use. This results in tighter, less verbose, more succinct code. The cost of this is a steeper learning curve and more complex mental model than when programming with Expected.\n Outcome has facilities to make easier interoperation between multiple third party libraries each using incommensurate Outcome configurations. Expected does not do any of this, but subsequent WG21 papers do propose various interoperation mechanisms, one of which Outcome implements so code using Expected will seamlessly interoperate with code using Outcome.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/hook_result/",
	"title": "Hook result",
	"tags": [],
	"description": "",
	"content": "We now tell Outcome that for every instance of our localised result\u0026lt;T\u0026gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.\nnamespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.  template \u0026lt;classT, classU\u0026gt; inline void hook_result_construction(result\u0026lt;T\u0026gt; *res, U \u0026amp;\u0026amp; /*unused*/) noexcept { if(res-\u0026gt;has_error()) { // Grab the next extended info slot in the TLS  extended_error_info \u0026amp;eei = mythreadlocaldata().next(); // Write the index just grabbed into the spare uint16_t  OUTCOME_V2_NAMESPACE::hooks::set_spare_storage(res, mythreadlocaldata().current - 1); // Capture a backtrace into my claimed extended info slot in the TLS  eei.items = ::backtrace(eei.backtrace.data(), eei.backtrace.size()); } } } View this code on Github The only non-obvious part above is the call to API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__set_spare_storage-R-S-NoValuePolicy--result_or_outcome-R-S-NoValuePolicy---uint16_t-. Both result and outcome keep their internal state metadata in a uint32_t, half of which is not used by Outcome. As it can be very useful to keep a small unique number attached to any particular result or outcome instance, we permit user code to set those sixteen bits to anything they feel like. The corresponding function to retrieve those sixteen bits is API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__spare_storage-R-S-NoValuePolicy--result_or_outcome-R-S-NoValuePolicy-const--.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/inspecting/",
	"title": "Inspecting outcome&lt;T, EC, EP&gt;",
	"tags": ["outcome", "value", "error", "exception"],
	"description": "",
	"content": "Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome\u0026lt;int\u0026gt; (which may store a double or an std::error_code or an std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_code\u0026rsquo;s:\nauto z() -\u0026gt; int // throws on failure { if (outcome::outcome\u0026lt;int\u0026gt; o = old::h()) return o.value(); else if (o.has_exception()) std::rethrow_exception(o.exception()); else throw std::system_error{o.error()}; } View this code on Github Function has_exception checks if it is EP (std::exception_ptr) that is stored, function exception accesses it. Similarly, function error accesses the EC (std::error_code) if it is stored. outcome\u0026lt;\u0026gt; also has a function has_failure to check if either EC or EP is being stored. In fact, the above pattern of \u0026ldquo;unpacking\u0026rdquo; outcome\u0026lt;\u0026gt; is so common that it has been implemented inside function .value(), so function z could be written as:\nreturn old::h().value(); "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-httplib1/",
	"title": "Mapping the HTTP library into the Application 1/2",
	"tags": [],
	"description": "",
	"content": "Firstly we are going to need to wrap up httplib::failure into a custom STL exception type before we can type erase it into an exception_ptr instance. Please note that this code is defined in the app namespace:\nnamespace app { // Specialise an exception type for httplib errors  struct httplib_error : std::runtime_error { // passthrough  using std::runtime_error::runtime_error; httplib_error(httplib::failure _failure, std::string msg) : std::runtime_error(std::move(msg)) , failure(std::move(_failure)) { } // the original failure  httplib::failure failure; }; // Type erase httplib::result\u0026lt;U\u0026gt; into a httplib_error exception ptr  template \u0026lt;classU\u0026gt; inline std::exception_ptr make_httplib_exception(const httplib::result\u0026lt;U\u0026gt; \u0026amp;src) { std::string str(\u0026#34;httplib failed with error \u0026#34;); switch(src.error().status) { case httplib::status_code::success: str.append(\u0026#34;success\u0026#34;); break; case httplib::status_code::bad_request: str.append(\u0026#34;bad request\u0026#34;); break; case httplib::status_code::access_denied: str.append(\u0026#34;access denied\u0026#34;); break; case httplib::status_code::logon_failed: str.append(\u0026#34;logon failed\u0026#34;); break; case httplib::status_code::forbidden: str.append(\u0026#34;forbidden\u0026#34;); break; case httplib::status_code::not_found: str.append(\u0026#34;not found\u0026#34;); break; case httplib::status_code::internal_error: str.append(\u0026#34;internal error\u0026#34;); break; } str.append(\u0026#34; [url was \u0026#34;); str.append(src.error().url); str.append(\u0026#34;]\u0026#34;); return std::make_exception_ptr(httplib_error(src.error(), std::move(str))); } } View this code on Github The only real thing to note about app::httplib_error is that it squirrels away the original httplib::failure in case that is ever needed. We do, of course, need to create some sort of descriptive string for std::runtime_error so its .what() returns a useful summary of the original failure. This is the purpose of the app::make_httplib_exception() function.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/static-constructor/",
	"title": "Phase 2 construction",
	"tags": [],
	"description": "",
	"content": "Its phase 2 constructor:\n// Phase 2 static member constructor function, which cannot throw inline outcome::result\u0026lt;file_handle\u0026gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret._fd = ::open(path.u8string().c_str(), flags); if(-1 == ret._fd) { // Note that if we bail out here, ~file_handle() will correctly not call ::close()  return {errno, std::system_category()}; } if(-1 == ::fstat(ret._fd, \u0026amp;ret._stat)) { // Note that if we bail out here, ~file_handle() will correctly call ::close()  return {errno, std::system_category()}; } // Returning ret directly is an area full of compiler specific behaviour quirks,  // so be explicit by wrapping into an initialiser list with embedded move.  return {std::move(ret)}; } View this code on Github The static member function implementing phase 2 firstly calls phase 1 which puts the object into a legally destructible state. We then proceed to implement phase 2 of construction, filling in the various parts as we go, reporting via result any failures.\nRemember that operator new has a non-throwing form, new(std::nothrow).\n For the final return, in theory we could just return ret and depending on the C++ version currently in force, it might work via move, or via copy, or it might refuse to compile. You can of course type lots of boilerplate to be explicit, but this use via initialiser list is a reasonable balance of explicitness versus brevity, and it should generate minimum overhead code irrespective of compiler, C++ version, or any other factor.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/try/",
	"title": "TRY operations",
	"tags": ["try"],
	"description": "",
	"content": "In the implementation of function print_half we have seen the usage of the macro try:\nOUTCOME_TRY (i, BigInt::fromString(text));  The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i,, the control statement is roughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure();  Where __result is a compile time generated unique name. If there are between two and eight parameters, this control statement is roughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto\u0026amp;\u0026amp; i = __result.value();  So here i as the first C macro parameter is set to the value of any successful result. To prevent confounding of the C preprocessor, you should always wrap the function invocation in brackets. This is done throughout this tutorial.\nAdditionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text));  This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i);  or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;));  This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n Macro OUTCOME_TRY does two things:\n It extracts a T from result\u0026lt;T\u0026gt; (or outcome\u0026lt;T\u0026gt;). It declares a dependency between statements: If the \u0026ldquo;tried\u0026rdquo; statement fails, the next statement is not executed.  When you are calling functions that return result\u0026lt;void\u0026gt; the first of the two things does not make sense. You then have to use macro OUTCOME_TRYV instead. Let\u0026rsquo;s use our function print_half:\noutcome::result\u0026lt;void\u0026gt; test() { OUTCOME_TRY ((print_half(\u0026#34;2\u0026#34;))); OUTCOME_TRY ((print_half(\u0026#34;X\u0026#34;))); OUTCOME_TRY ((print_half(\u0026#34;4\u0026#34;))); // will not execute  return outcome::success(); } View this code on Github The first statement will succeed. The second statement will \u0026ldquo;fail\u0026rdquo;, i.e. it will return an errored result. This will cause an immediate return and the subsequent statements will be skipped.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/traits/",
	"title": "Traits",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/",
	"title": "Traits",
	"tags": [],
	"description": "",
	"content": " has_error_code\u0026lt;T\u0026gt; True if an error code can be constructed from a T.\n has_exception_ptr\u0026lt;T\u0026gt; True if an exception ptr can be constructed from a T.\n is_basic_result\u0026lt;T\u0026gt; An integral constant type true for `basic_resulttypes.\n is_error_type\u0026lt;E\u0026gt; A customisable integral constant type true for E types which are to receive error throwing no-value policies.\n is_error_type_enum\u0026lt;E, Enum\u0026gt; A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies.\n type_can_be_used_in_basic_result\u0026lt;R\u0026gt; A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-httplib2/",
	"title": "Mapping the HTTP library into the Application 2/2",
	"tags": [],
	"description": "",
	"content": "If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from httplib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;classT, classU\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, httplib::result\u0026lt;U\u0026gt;\u0026gt; { // False to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;classX, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;httplib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.has_value() ? //  app::outcome\u0026lt;T\u0026gt;{std::forward\u0026lt;X\u0026gt;(src).value()} //  : app::outcome\u0026lt;T\u0026gt;{app::make_httplib_exception(std::forward\u0026lt;X\u0026gt;(src))}; } }; } OUTCOME_V2_NAMESPACE_END View this code on Github The first thing that you should note is that these custom converters must be injected directly into the OUTCOME_V2_NAMESPACE::convert namespace, and they must partially or completely specialise struct value_or_error\u0026lt;DEST, SRC\u0026gt;.\nThe second thing to note is that you need to set enable_result_inputs and enable_outcome_inputs appropriately. The reason that these are here is because of a chicken-or-egg problem whereby the ValueOrError infrastructure needs to be defined before result can be defined, and we also wish to permit inclusion of result without needing to include outcome. So this is a slightly irritating workaround, but one with low impact.\nThe third thing to note is the SFINAE on operator(). If the SFINAE fails, the ValueOrError converting constructor disables. Obviously, if you are using Concept requirements, that works too. Note the requirement that SFINAEd X matches httplib::result\u0026lt;U\u0026gt;, and that T is constructible from U.\nIf operator() is available, it naturally converts a httplib::result\u0026lt;U\u0026gt; into an app::outcome\u0026lt;T\u0026gt; by either forwarding any success as-is, or calling app::make_httplib_exception() to type erase the httplib::failure into an app::httplib_error.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/poke_exception/",
	"title": "Custom exception ptr",
	"tags": [],
	"description": "",
	"content": "If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.\nBut let\u0026rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:\nnamespace error_code_extended { // Synthesise a custom exception_ptr from the TLS slot and write it into the outcome  template \u0026lt;classR\u0026gt; inline void poke_exception(outcome\u0026lt;R\u0026gt; *o) { if(o-\u0026gt;has_error()) { extended_error_info *eei = mythreadlocaldata().get(OUTCOME_V2_NAMESPACE::hooks::spare_storage(o)); if(eei != nullptr) { // Make a custom string for the exception  std::string str(o-\u0026gt;error().message()); str.append(\u0026#34; [\u0026#34;); char **symbols = ::backtrace_symbols(eei-\u0026gt;backtrace.data(), eei-\u0026gt;items); if(symbols != nullptr) { for(size_t n = 0; n \u0026lt; eei-\u0026gt;items; n++) { if(n \u0026gt; 0) { str.append(\u0026#34;; \u0026#34;); } str.append(symbols[n]); } ::free(symbols); // not exception safe, could leak symbols if appending str fails  } str.append(\u0026#34;]\u0026#34;); // Override the payload/exception member in the outcome with our synthesised exception ptr  OUTCOME_V2_NAMESPACE::hooks::override_outcome_exception(o, std::make_exception_ptr(std::runtime_error(str))); } } } } View this code on Github If the localised outcome being constructed is errored, try fetching the TLS slot for the unique 16-bit value in its spare storage. If that is valid, symbolise the stack backtrace into a string and make an exception ptr with a runtime error with that string. Finally, override the payload/exception member in our just-copy-constructed localised outcome with the new exception ptr.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-filelib/",
	"title": "Mapping the File I/O library into the Application",
	"tags": [],
	"description": "",
	"content": "To handle the File I/O library, once again we turn to custom ValueOrError converters:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;classT, classU\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, filelib::result\u0026lt;U\u0026gt;\u0026gt; { // True to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;classX, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;filelib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value  if(src.has_value()) { return {std::forward\u0026lt;X\u0026gt;(src).value()}; } // Synthesise a filesystem_error, exactly as if someone had called src.value()  auto \u0026amp;fi = src.error(); OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // might throw  return {std::make_exception_ptr(filelib::filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec))}; } }; } OUTCOME_V2_NAMESPACE_END View this code on Github Note that the conversion exactly duplicates the implementation of throw_as_system_error_with_payload(failure_info fi) from namespace filelib.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg1/",
	"title": "Phase 3",
	"tags": [],
	"description": "",
	"content": "We have built our first two phases of construction for file_handle, and for some users they might be happy writing:\noutcome::result\u0026lt;file_handle\u0026gt; fh1 = file_handle::file(\u0026#34;hello\u0026#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh1.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github \u0026hellip; and be done with it.\nBut wouldn\u0026rsquo;t it be nicer if we could instead write:\noutcome::result\u0026lt;file_handle\u0026gt; fh2 = construct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34; /*, file_handle::mode::read */}(); if(!fh2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh2.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github The eye is immediately drawn to the two-stage invocation pattern, so we are constructing a type construct\u0026lt;file_handle\u0026gt; using the arguments with which we wish to invoke the file_handle constructor with, and then invoking the call operator on that construct\u0026lt;file_handle\u0026gt; instance to do the actual construction.\nWe think that this is a better approach than alternatives, but we shall briefly cover those at the end of this section.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/variations/",
	"title": "Variations",
	"tags": [],
	"description": "",
	"content": "You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with API NOT FOUND IN DOCS result_c/#standardese-CXX_DECLARE_RESULT, refer to it with API NOT FOUND IN DOCS result_c/#standardese-CXX_RESULT and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =\nstruct cxx_error_code { int code; void *category; }; \u0026hellip; which is declared for you by result.h.\nOutcome\u0026rsquo;s C support was designed assuming that you do not wish to penalise the performance of C++ code calling these C-compatible C++ functions, but if you don\u0026rsquo;t care about that, then always setting errno to any error in a result\u0026lt;T\u0026gt; is easily implemented and thus the natural C use pattern becomes available:\nextern size_t to_string(char *buffer, size_t bufferlen, int v); ... size_t len = to_string(buffer, sizeof(buffer), v); if(errno != 0) ... Implementing this via boilerplate generating script is straightforward, and is left as an exercise to the interested reader.\n"
},
{
	"uri": "https://ned14.github.io/outcome/videos/",
	"title": "Videos",
	"tags": [],
	"description": "",
	"content": " Outcome has been presented at some of the major C++ conferences as it has evolved. As the older content is less relevant to Outcome today, this list is given in reverse chronological order.\nDublin C++ users group 2018 \u0026ldquo;Deterministic Disappointment\u0026rdquo; Literature review of the WG21 papers relating to deterministically handling failure, and using libraries such as Outcome to implement the same.\n   Meeting C++ 2017 \u0026ldquo;Introduction to proposed std::expected\u0026lt;T, E\u0026gt;\u0026ldquo; Literature review of the several WG21 papers relating to std::expected.\n   ACCU 2017 \u0026ldquo;Mongrel Monads, Dirty, dirty, dirty\u0026rdquo; Covers the history of error handling in C++, and how the LEWG Expected works.\n(Note that the Expected presented here no longer exists, it was substantially changed after the Outcome v1 peer review. Furthermore the Outcome presented here no longer exists, the peer review demanded a complete rebuild)\n   "
},
{
	"uri": "https://ned14.github.io/outcome/motivation/std_error_code/",
	"title": "std::error_code",
	"tags": [],
	"description": "Overview of std::error_code",
	"content": " std::error_code Type std::error_code has been designed to be sufficiently small and trivial to be cheaply passed around, and at the same time be able to store sufficient information to represent any error situation from any library/sub-system in the world without a clash. Its representation is basically:\nclasserror_code { error_category* domain; // domain from which the error originates  int value; // numeric value of error within the domain };  Here, domain indicates the library from which the error originates. It is a pointer to a global object representing a given library/domain. Different libraries will be represented by different pointers to different globals. Each domain is expected to be represented by a global object derived from std::error_category. The uniqueness of the domain pointer value is guaranteed by the uniqueness of addresses of different global objects.\nNow, value represents a numeric value of a particular error situation within the domain. Thus, different domains can use the same numeric value 1 to indicate different error situations, but two std::error_code objects will be different because the pointers representing domains will be different.\nstd::error_code comes with additional tools: a facility for defining custom domains with their set of error codes, and a facility for building predicates that allow classifying errors.\nOnce created and passed around (either inside a thrown exception or returned from functions by value) there is never a need to change the value of error_code object at any level. But at different levels one can use different predicates for classifying error situations appropriately to the program layer.\nWhen a new library needs to represent its own set of error situations in an error_code it first has to declare the list of numeric value as an enumeration:\nenum classConvertErrc { StringTooLong = 1, // 0 should not represent an error  EmptyString = 2, IllegalChar = 3, };  Then it has to put some boiler-plate code to plug the new enumeration into the std::error_code system. Then, it can use the enum as an error_code:\nstd::error_code ec = ConvertErrc::EmptyString; assert(ec == ConvertErrc::EmptyString);  Member value is mapped directly from the numeric value in the enumeration, and member domain is mapped from the type of the enumeration. Thus, this is a form of type erasure, but one that does allow type std::error_code to be trivial and standard-layout.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-tidylib/",
	"title": "Mapping the HTMLTidy library into the Application",
	"tags": [],
	"description": "",
	"content": "Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.\nnamespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.  struct call_free { template \u0026lt;classT\u0026gt; void operator()(T *p) { ::free(p); } }; inline outcome\u0026lt;std::unique_ptr\u0026lt;char, call_free\u0026gt;\u0026gt; tidy_html(string_view \u0026amp;data) { char *out = nullptr; size_t outlen = 0; int errcode = ::tidy_html(\u0026amp;out, \u0026amp;outlen, data.data(), data.size()); if(errcode != 0) { // If the error code matches a standard STL exception, throw as that.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(std::error_code(errcode, std::generic_category())); // Otherwise wrap the error code into a tidylib_error exception throw  return std::make_exception_ptr(tidylib_error(errcode)); } // Reset input view to tidied html  data = string_view(out, outlen); // Return a unique ptr to release storage on scope exit  return std::unique_ptr\u0026lt;char, call_free\u0026gt;(out); } } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/",
	"title": "Result returning constructors",
	"tags": ["constructors"],
	"description": "How to metaprogram construction of objects which use result&lt;T, EC&gt; to return failure instead of throwing a C++ exception.",
	"content": "An oft asked question during conference talks on Expected/Outcome is how to exclusively use result to implement constructor failure. This is asked because whilst almost every member function in a class can return a result, constructors do not return values and thus cannot return a result. The implication is that one cannot avoid throwing C++ exceptions to abort a construction.\nAs with most things in C++, one can achieve zero-exception-throw object construction using a lot of extra typing of boilerplate, and a little bit of simple C++ metaprogramming. This section shows you how to implement these for those who are absolutely adverse to ever throwing an exception, or cannot because C++ exceptions have been globally disabled.\nThe technique described here is not suitable for non-copyable and non-movable types. There is also an assumption that moving your type is cheap.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/",
	"title": "Hook outcome",
	"tags": [],
	"description": "",
	"content": "The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn\u0026rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.\nnamespace error_code_extended { // Specialise the outcome copy and move conversion hook for when our localised result  // is used as the source for copy construction our localised outcome  template \u0026lt;classT, classU\u0026gt; inline void hook_outcome_copy_construction(outcome\u0026lt;T\u0026gt; *res, const result\u0026lt;U\u0026gt; \u0026amp; /*unused*/) noexcept { // when copy constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } template \u0026lt;classT, classU\u0026gt; inline void hook_outcome_move_construction(outcome\u0026lt;T\u0026gt; *res, result\u0026lt;U\u0026gt; \u0026amp;\u0026amp; /*unused*/) noexcept { // when move constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/",
	"title": "Hooking events",
	"tags": ["hooks"],
	"description": "Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.",
	"content": "Outcome provides multiple methods for user code to intercept various events which occur. The deepest is simply to inherit from result or outcome and override member functions, for which you will need to study the source code as that form of customisation is out of scope for this tutorial. Another option is to supply a custom NoValuePolicy (see next section). The final option, which this section covers, is to use the ADL discovered event hooks which tell you when a namespace-localised outcome or result has been:\n Constructed   API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__hook_result_construction-T-U--T--U---  API NOT FOUND IN DOCS outcome/#standardese-outcome_v2_xxx__hooks__hook_outcome_construction-T-U--T--U---  In-place constructed   API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__hook_result_in_place_construction-T-U-Args--T--in_place_type_t-U--Args------  API NOT FOUND IN DOCS outcome/#standardese-outcome_v2_xxx__hooks__hook_outcome_in_place_construction-T-U-Args--T--in_place_type_t-U--Args------  Copied   API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__hook_result_copy_construction-T-U--T--U---  API NOT FOUND IN DOCS outcome/#standardese-outcome_v2_xxx__hooks__hook_outcome_copy_construction-T-U--T--U---  Moved   API NOT FOUND IN DOCS result/#standardese-outcome_v2_xxx__hooks__hook_result_move_construction-T-U--T--U---  API NOT FOUND IN DOCS outcome/#standardese-outcome_v2_xxx__hooks__hook_outcome_move_construction-T-U--T--U---   One criticism often levelled against these success-or-failure objects is that they do not provide as rich a set of facilities as C++ exception throws. This section shows you how to configure Outcome using the ADL event hooks to take a stack backtrace on construction of an errored result\u0026lt;T, error_code\u0026gt;, and if that result\u0026lt;T, error_code\u0026gt; should ever be converted into an outcome\u0026lt;T, error_code, std::exception_ptr\u0026gt;, a custom std::exception_ptr will be just-in-time synthesised consisting of the std::system_error for the error code, plus an expanded message string containing the stack backtrace of where the error originally occurred. One can see the use case for fixed latency code being built with result, and it dovetailing into application code where execution time guarantees are not important where a malloc is permitted.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-go/",
	"title": "In use",
	"tags": [],
	"description": "",
	"content": "This is how you might now write application code using these three libraries:\nnamespace app { outcome\u0026lt;void\u0026gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result. This makes it explicit what you intend to do as conversion  // may be a lot more expensive than moves.  // Try to GET this URL. If an unsuccessful HTTP status is returned, serialise a string  // containing a description of the HTTP status code and the URL which failed, storing  // that into a httplib_error exception type which is stored as an exception ptr. The  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the fetched data is returned in a std::string data.  OUTCOME_TRY(data, (outcome\u0026lt;std::string\u0026gt;(httplib::get(\u0026#34;http://www.nedproductions.biz/\u0026#34;)))); string_view data_view(data); // HTML tidy the fetched data. If the C library fails due to an error corresponding to  // a standard library exception type, throw that. Otherwise, synthesise an exception  // ptr of type tidylib_error which stores the error code returned in an error code with  // generic category (i.e. errno domain).  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the tidied data is returned into holdmem, with the string view updated to  // point at the tidied data.  OUTCOME_TRY(holdmem, (tidy_html(data_view))); // Write the tidied data to some file. If the write fails, synthesise a filesystem_error  // exception ptr exactly as if one called filelib::write_file(data_view).value().  OUTCOME_TRY(written, (outcome\u0026lt;size_t\u0026gt;(filelib::write_file(data_view)))); return success(); } } View this code on Github Many will wish that the explicit converting wrappers around third party library APIs were not there. Note that in C++ 17 you should be able to dispense with the angle bracketed type as the compiler can now deduce that. But one must still wrap all third party API invocations with outcome() i.e. explicit construction to namespace-localised outcome. This is a deliberate design decision: in Outcome, all converting construction is always explicit, except when the source is success or failure type sugar. And down the line when others come to maintain this code, we think it will be very useful to be explicit on this because user defined code that we customised earlier is being executed.\nNote also that we are able to use TRY throughout this function, and most especially note that we never, at any stage, needed to modify the source code of httplib, tidylib nor filelib, or inject custom things into their namespaces. This entire worked example was achieved solely by app based customisation points and via convert.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/plug_error_code/",
	"title": "Plugging a library into std::error_code",
	"tags": [],
	"description": "Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.",
	"content": "This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in converting a std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al // This is the custom error code enum enum classConversionErrc { Success = 0, // 0 should not represent an error  EmptyString = 1, IllegalChar = 2, TooLong = 3, }; namespace std { // Tell the C++ 11 STL metaprogramming that enum ConversionErrc  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type { }; } namespace detail { // Define a custom error code category derived from std::error_category  classConversionErrc_category : public std::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::Success: return \u0026#34;conversion successful\u0026#34;; case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit chatr when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual std::error_condition default_error_condition(int c) const noexcept override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(std::errc::result_out_of_range); default: // I have no mapping for this code  return std::error_condition(c, *this); } } }; } // Define the linkage for this function to be used by external code. // This would be the usual __declspec(dllexport) or __declspec(dllimport) // if we were in a Windows DLL etc. But for this example use a global // instance but with inline linkage so multiple definitions do not collide. #define THIS_MODULE_API_DECL extern inline  // Declare a global function returning a static instance of the custom category THIS_MODULE_API_DECL const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline std::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  std::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; } View this code on Github This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  This documentation recommends that when you define your custom enum for representing error_codes, you should always make sure that value 0 never represents an actual error: it should either represent a success or should not be provided at all. If you only intend to use your enum inside result\u0026lt;\u0026gt; or outcome\u0026lt;\u0026gt; you can just start your enumerations from 1. If you intend to also return std::error_code directly from functions, you should probably define value 0 as success, so that you are able to inform about function\u0026rsquo;s success by returning MyEnum::Success. This is because error_code\u0026rsquo;s contextual conversion to bool (which some people use to check if there was an error or not) only checks for the numeric value of the error code (without looking at error domain (category)).\n [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": " basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; A sum type carrying either a successful T, or a disappointment E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n basic_result() = delete The default constructor (disabled).\n basic_result(basic_result \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_result(const basic_result \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(basic_result \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(const basic_result \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_result() Destructor. Constexpr, triviality and noexcept propagating.\n basic_result(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_result(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n basic_result(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(ValueOrError\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from ValueOrError\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error constructor. Available if predicate::enable_inplace_value_error_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n in_place_type_t\u0026lt;T\u0026gt; Either std::in_place_type_t\u0026lt;T\u0026gt; if C++ 17 or later, else a local emulation.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg2/",
	"title": "construct&lt;T&gt;",
	"tags": [],
	"description": "",
	"content": "First, we need a base definition for construct\u0026lt;T\u0026gt;:\ntemplate \u0026lt;classT\u0026gt; struct construct { outcome::result\u0026lt;T\u0026gt; operator()() const noexcept { //  static_assert(!std::is_same\u0026lt;T, T\u0026gt;::value, \u0026#34;construct\u0026lt;T\u0026gt;() was not specialised for the type T supplied\u0026#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.\nWe then specialise for construct\u0026lt;file_handle\u0026gt;:\ntemplate \u0026lt;\u0026gt; struct construct\u0026lt;file_handle\u0026gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here ...  outcome::result\u0026lt;file_handle\u0026gt; operator()() const noexcept { return file_handle::file(std::move(_path)); } }; View this code on Github Because this is a struct, we can list initialise construct, and use default member initialisers to implement default arguments. This can get you surprisingly far before you need to start writing custom constructors.\nBut in more complex code, you will usually provide all the initialisation overloads that you would for the constructors of your main type. You then implement a single phase 2 constructing function which accepts construct\u0026lt;YOURTYPE\u0026gt; as input, and construct solely from that source.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace.\nHowever there are occasions when you don\u0026rsquo;t have control over the implementation of the destination E type e.g. in callbacks. Outcome\u0026rsquo;s ValueOrError infrastructure lets you inject custom interop code for any pair of incommensurate third party E types, without needing to modify either\u0026rsquo;s source code. This is without doubt a \u0026ldquo;power users\u0026rdquo; feature, but one which will prove useful as T|E based C++ code proliferates.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/",
	"title": "Aliases",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg3/",
	"title": "Alternatives",
	"tags": [],
	"description": "",
	"content": "No doubt many will dislike the two-stage invocation pattern i.e.\nconstruct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34;}();  So let us examine the most obvious alternative: a templated free function construct\u0026lt;T\u0026gt;.\nDue to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.\ntemplate\u0026lt;class... Args\u0026gt; inline outcome::result\u0026lt;file_handle\u0026gt; construct(std::in_place_type_t\u0026lt;file_handle\u0026gt;, Args\u0026amp;\u0026amp; ... args) { return file_handle::file(std::forward\u0026lt;Args\u0026gt;(args)...); } ... // Now you must always write this: construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026#34;hello\u0026#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:\n It takes longer to type construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026quot;hello\u0026quot;), and is possibly less intuitive to write, than it does construct\u0026lt;file_handle\u0026gt;{\u0026quot;hello\u0026quot;}(). Compiler error messages are enormously clearer if you encode the permitted overloads for construction into the construct\u0026lt;file_handle\u0026gt; type rather than letting a variadic free function fail to resolve an appropriate overload. Resolving variadic free function overloads is not constant time for the compiler, whereas resolving the type specialisation for construct\u0026lt;file_handle\u0026gt; is constant time. It actually turns out to be quite useful when writing generic code to pass around object constructing factory objects all of which have no parameters for their call operator. It becomes, effectively, a lazy construction mechanism.  "
},
{
	"uri": "https://ned14.github.io/outcome/motivation/narrow_contract/",
	"title": "Narrow contracts",
	"tags": [],
	"description": "Describes narrow-contract functions that do not work for all input values, and advantage of using them.",
	"content": "A program\u0026rsquo;s thread of execution can enter a \u0026ldquo;disappointing\u0026rdquo; state for two reasons:\n due to disappointing situation in the environment (operating system, external input), or due to a bug in the program.  The key to handling these disappointments correctly is to identify to which category they belong, and use the tools adequate for a given category. In this tutorial when we say \u0026ldquo;error\u0026rdquo; or \u0026ldquo;failure\u0026rdquo; we only refer to the first category. A bug is not an error.\nA bug is when a program is something else than what it is supposed to be. The correct action in that case is to change the program so that it is exactly what it is supposed to be. Unfortunately, sometimes the symptoms of a bug are only detected when the system is running and at this point no code changes are possible.\nIn contrast, a failure is when a correct function in a correct program reflects some disappointing behavior in the environment. The correct action in that case is for the program to take a control path different than usual, which will likely cancel some operations and will likely result in different communication with the outside world.\nSymptoms of bugs can sometimes be detected during compilation or static program analysis or at run-time when observing certain values of objects that are declared never to be valid at certain points. One classical example is passing a null pointer to functions that expect a pointer to a valid object:\nint f(int * pi) // expects: pi != nullptr { return *pi + 1; }  Passing a null pointer where it is not expected is so common a bug that tools are very good at finding them. For instance, static analyzers will usually detect it without even executing your code. Similarly, tools like undefined behavior sanitizers will compile a code as the one above so that a safety check is performed to check if the pointer is null, and an error message will be logged and program optionally terminated.\nMore, compilers can perform optimizations based on undefined behavior caused by dereferencing a null pointer. In the following code:\npair\u0026lt;int, int\u0026gt; g(int * pi) // expects: pi != nullptr { int i = *pi + 1; int j = (pi == nullptr) ? 1 : 0; return {i, j}; }  The compiler can see that if pi is null, the program would have undefined behavior. Since undefined behavior is required by the C++ standard to never be the programmer\u0026rsquo;s intention, the compiler assumes that apparently this function is never called with pi == nullptr. If so, j is always 0 and the code can be transformed to a faster one:\npair\u0026lt;int, int\u0026gt; g(int * pi) // expects: pi != nullptr { int i = *pi + 1; int j = 0; return {i, j}; }  Functions like the one above that declare that certain values of input parameters must not be passed to them are said to have a narrow contract.\nCompilers give you non-standard tools to tell them about narrow contracts, so that they can detect it and make use of it the same way as they are detecting invalid null pointers. For instance, if a function in your library takes an int and declares that the value of this int must never be negative. You can use __builtin_trap() available in GCC and clang:\nvoid h(int i) // expects: i \u0026gt;= 0 { if (i \u0026lt; 0) __builtin_trap(); // normal program logic follows ... }  This instruction when hit, causes the program to exit abnormally, which means: * a debugger can be launched, * static analyzer can warn you if it can detect a program flow that reaches this point, * UB-sanitizer can log error message when it hits it.\nAnother tool you could use is __builtin_unreachable(), also available in GCC and clang:\nvoid h(int i) // expects: i \u0026gt;= 0 { if (i \u0026lt; 0) __builtin_unreachable(); // normal program logic follows ... }  This gives a hint to the tools: the programmer guarantees that the program flow will never reach to the point of executing it. In other words, it is undefined behavior if control reaches this point. Compiler and other tools can take this for granted. This way they can deduce that expression i \u0026lt; 0 will never be true, and they can further use this assumption to issue warnings or to optimize the code. UB-sanitizers can use it to inject a log message and terminate if this point is nonetheless reached.\nAllowing for some input values to be invalid works similarly to cyclic redundancy checks. It allows for the possibility to observe the symptoms of the bugs (not the bugs themselves), and if the symptom is revealed the hunt for the bug can start. This is not only tools that can now easily detect symptoms of bugs, but also humans during the code review. A reviewer can now say, \u0026ldquo;hey, function h() is expecting a non-negative value, but this i is actually -1; maybe you wanted to pass j instead?\u0026ldquo;.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Traits "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/",
	"title": "Using result&lt;T&gt; from C code",
	"tags": [],
	"description": "Interacting with result&lt;T, EC&gt; returning C++ functions from C code.",
	"content": "A long standing problem for C code (or more usually nowadays, the many other programming languages which can speak the C ABI but not the C++ ABI) is how to interpret C++ exception throws. The answer is of course that they cannot, thus requiring one to write C shim code on the C++ side of things of the form:\n// The API we wish to expose to C const char *get_value(double v); // The C shim function for the C++ get_value() function. extern \u0026#34;C\u0026#34; int c_get_value(const char **ret, double v) { try { *ret = get_value(v); return 0; // success  } catch(const std::range_error \u0026amp;) { return ERANGE; } // More catch clauses may go in here ...  catch(...) { return EAGAIN; } }  This is sufficiently painful that most reach for a bindings generator tool like SWIG to automate this sort of tedious boilerplate generation. And this is fine for larger projects, but for smaller projects the cost of setting up and configuring SWIG is also non-trivial.\nWhat would be really great is if result\u0026lt;T\u0026gt; returning noexcept C++ functions could be used straight from C. And indeed Outcome provides just that facility which this section covers next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/changelog/",
	"title": "Changelog",
	"tags": [],
	"description": "",
	"content": " v2.1 in progress [project]  #152\n GCC 5 no longer can compile Outcome at all due to https://stackoverflow.com/questions/45607450/gcc5-nested-variable-template-is-not-a-function-template. Added explicit version trap for GCC 5 to say it can not work. Note this is not a breaking change, GCC 5 was never supported officially in any v2 Outcome.  #150\n BREAKING CHANGE result\u0026lt;T, E\u0026gt;, boost_result\u0026lt;T, E\u0026gt; and std_result\u0026lt;T, E\u0026gt; no longer implement hard UB on fetching a value from a valueless instance if E is a UDT, they now fail to compile with a useful error message. If you wish hard UB, use unchecked\u0026lt;T, E\u0026gt;, boost_unchecked\u0026lt;T, E\u0026gt; or std_unchecked\u0026lt;T, E\u0026gt; instead.  #140\n Fixed a nasty corner case bug where value type\u0026rsquo;s without a copy constructor but with a move constructor would indicate via traits that copy construction was available. Thanks to Microsoft\u0026rsquo;s compiler team for reporting this issue.  Added experimental status_result and status_outcome based on experimental status_code.\n Boost edition is now 100% Boost, so defaults for result and outcome are boost::system::error_code::errc_t and boost::exception_ptr. Moreover, the test suite in the Boost edition now exclusively tests the Boost edition. One can, of course, freely use the standalone edition with Boost, and the Boost edition with std types.\n Renamed ADL discovered customisation point throw_as_system_error_with_payload() to outcome_throw_as_system_error_with_payload().\n #135\n Added much clearer compile failure when user tries result\u0026lt;T, T\u0026gt; or outcome where two or more types are identical. Thanks to Andrzej Krzemie≈Ñski for suggesting a technique which combines SFINAE correctness with the remaining ability for result\u0026lt;T, T\u0026gt; etc to be a valid type, but not constructible.  #67\n Fixed one of the oldest long open bugs in Outcome, that the noexcept unit tests failed on OS X for an unknown reason.  #115\n Outcome did not construct correctly from failure_type.  Inexplicably outcome\u0026rsquo;s error + exception constructor had been removed. Nobody noticed during the Boost peer review, which is worrying seeing as that constructor is needed for one of the main advertised features to Boost!\n #107 and #116\n operator== and operator!= now become disabled if the value, error and exception types do not implement the same operator. Relatedly, both comparison operators simply didn\u0026rsquo;t work right. Fixed.  #109\n swap() now has correct noexcept calculation and now correctly orders the swaps to be whichever is the throwing swap first.  Added reference dump of v2.1 ABI so we can check if ABI breakage detection works in the next set of changes, plus Travis job to check ABI and API compatibility per commit.\n #124\n OUTCOME_TRY is now overloaded and selects void or auto edition according to input parameter count.  #120\n Fix generation of double underscored temporary variables in OUTCOME_UNIQUE_NAME, which is UB.  #110\n Separated result from its hard coded dependency on the \u0026lt;system_error\u0026gt; header. Renamed result and outcome to basic_result and basic_outcome. Renamed result.hpp into basic_result.hpp. Moved \u0026lt;system_error\u0026gt; and \u0026lt;exception\u0026gt; dependent code into new std_result.hpp and std_outcome.hpp header files. Added boost_result.hpp and boost_outcome.hpp which use Boost.System and Boost.Exception (these are result.hpp and outcome.hpp in the Boost edition).   v2.0 18th Jan 2018 [release]  Boost peer review edition. This is what was reviewed. Changelog from v1 can be found in the release notes for this release.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/",
	"title": "Interoperation",
	"tags": [],
	"description": "Interoperating with std::expected&lt;T, E&gt; and other ValueOrError concept matching types.",
	"content": "This is the final section of the tutorial, and it is unavoidably quite lengthy.\nOne thing which Outcome solves \u0026ndash; which alternatives do not \u0026ndash; is how to non-intrusively tie together multiple third party libraries, each using Outcome \u0026ndash; or some other T|E implementatation like std::expected\u0026lt;T, E\u0026gt; \u0026ndash; with custom incommensurate E types, or indeed arbitrary return types which are \u0026ldquo;split\u0026rdquo; T|E return types. Solving this well is the coup de gr√¢ce of Outcome against alternative approaches to this problem domain, including std::expected\u0026lt;T, E\u0026gt;. It is the major reason why you should consider using Outcome over alternatives, including Expected.\nFirstly we shall explore some of the problems faced by the software developer when T|E return type based code proliferates at scale, where dozens of libraries may be using completely incompatible T|E return types.\nSecondly we shall introduce the ValueOrError concept support in Outcome which implements a subset of the proposed WG21 ValueOrError concept framework.\nFinally, we shall then step through a worked example which mocks up a realistic situation that the software developer may find themselves in: tying together disparate third party libraries, whose source code cannot be modified, into an application-wide, mixed-mode T|E and exception throwing universal error handling system which is capable of accurately representing the original failure, but also propagating it in a way that the application can deal with universally.\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\nmermaid.initialize({startOnLoad:true}); gantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2 (complete redesign based on first review feedback): done, des3, after des2, 2018-01 Boost peer review of v2: done, des4, after des3, 30d Outcome v2.1 (changes from second review): active, des5, 2018-03, 2019-04 section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d Boost.Outcome generated by script from Outcome repo: crit, done, 2017-10,2d New tutorial finally complete: crit, done, 2017-12,2d Outcome v2.1 feature complete, maturation begins: crit, done, 2018-04,2d Boost.Outcome docs gain BoostDoc theming: crit, done, 2018-12,2d Planned release of v2.1 into Boost 1.70: crit, active, 2019-04,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;. Significant backwards compatibility with v1 Outcome code was retained, as the review had felt the basic proposed design fine.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo;, and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available.\nAll that remained before it was ready for a second Boost peer review was the documentation. This took four months to write (same time as to write the library itself!), and in January 2018 Outcome had its second Boost peer review, which it passed!\nPost-review Outcome passing its review in January had much more consequence than I could have ever expected. Unbeknownst to me, the WG21 leadership had interpreted the success of Outcome, and especially its divergences from WG21 Expected, as a sign that the C++ exception handling mechanism was no longer fit for purpose. It was thus resolved to remedy the standard exception handling mechanism into something much more efficient, thus rendering Outcome obsolete in future C++ standards.\nJust before the review, I had mooted a number of semantic and compile time performance improvements to \u0026lt;system_error\u0026gt; with the proposal that we mildly break Boost.System with improvements and see how badly real world code broke in response. This was not widely accepted. I therefore wrote an improved \u0026lt;system_error2\u0026gt; which fixed all the problems listed at P0824 (Summary of SG14 discussion on \u0026lt;system_error\u0026gt;) and fixed up Outcome so one could use it without any system error implementation, or with the STL one or with the proposed improved one.\nTo be continued after Jacksonville \u0026hellip;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/default/",
	"title": "`basic_result() = delete`",
	"tags": [],
	"description": "The default constructor (disabled).",
	"content": "The default constructor for basic result is always disabled.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/",
	"title": "`basic_result(basic_result &amp;&amp;)`",
	"tags": [],
	"description": "Move constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Move constructor.\nRequires: that value_type and error_type both implement a move constructor.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/",
	"title": "`basic_result(const basic_result &amp;)`",
	"tags": [],
	"description": "Copy constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Copy constructor.\nRequires: that value_type and error_type both implement a copy constructor.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/",
	"title": "`basic_result &amp;operator=(basic_result &amp;&amp;)`",
	"tags": [],
	"description": "Move assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Move assignment.\nRequires: that value_type and error_type both implement move assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type\u0026rsquo;s move assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/",
	"title": "`basic_result &amp;operator=(const basic_result &amp;)`",
	"tags": [],
	"description": "Copy assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Copy assignment.\nRequires: that value_type and error_type both implement copy assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type\u0026rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/destructor/",
	"title": "`~basic_result()`",
	"tags": [],
	"description": "Destructor. Constexpr, triviality and noexcept propagating.",
	"content": "Destructor.\nRequires: Always available.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/",
	"title": "`basic_result(Args...) = delete`",
	"tags": [],
	"description": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when `predicate::constructors_enabled` is false.",
	"content": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\nRequires: predicate::constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/",
	"title": "`basic_result(X &amp;&amp;) = delete`",
	"tags": [],
	"description": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when `predicate::implicit_constructors_enabled` is false.",
	"content": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\nRequires: predicate::implicit_constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/",
	"title": "`basic_result(R &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `value_type` constructor. Available if `predicate::enable_value_converting_constructor&lt;R&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value_type constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) with this and R.\nRequires: predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for value_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/",
	"title": "`basic_result(S &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` constructor. Available if `predicate::enable_error_converting_constructor&lt;S&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) with this and S.\nRequires: predicate::enable_error_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/",
	"title": "`basic_result(ErrorCondEnum &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` from `ErrorCondEnum` constructor. Available if `predicate::enable_error_condition_converting_constructor&lt;ErrorCondEnum&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type from ErrorCondEnum constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) with this and ErrorCondEnum.\nRequires: predicate::enable_error_condition_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/",
	"title": "`explicit basic_result(ValueOrError&lt;T, E&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting constructor from `ValueOrError&lt;T, E&gt;` concept matching types. Available if `convert::value_or_error&lt;&gt;` permits it. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting constructor from ValueOrError\u0026lt;T, E\u0026gt; concept matching types. Delegates to the basic_result move constructor.\nRequires: convert::value_or_error\u0026lt;T, U\u0026gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error\u0026lt;\u0026gt; has enabled those inputs for that convert::value_or_error\u0026lt;\u0026gt; specialisation.\nComplexity: Same as for the copy or move constructor from the input\u0026rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/",
	"title": "`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls API NOT FOUND IN DOCS hook_result_copy_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/",
	"title": "`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls API NOT FOUND IN DOCS hook_result_move_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/",
	"title": "`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls API NOT FOUND IN DOCS hook_result_in_place_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, Args ...) with this, in_place_type\u0026lt;value_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/",
	"title": "`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls API NOT FOUND IN DOCS hook_result_in_place_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, Args ...) with this, in_place_type\u0026lt;value_type\u0026gt;, \u0026lsquo;std::initializer_list\u0026rsquo; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/",
	"title": "`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls API NOT FOUND IN DOCS hook_result_in_place_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, Args ...) with this, in_place_type\u0026lt;error_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/",
	"title": "`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls API NOT FOUND IN DOCS hook_result_in_place_construction(basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; *, Args ...) with this, in_place_type\u0026lt;error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/",
	"title": "`basic_result(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`",
	"tags": [],
	"description": "Implicit inplace value or error constructor. Available if `predicate::enable_inplace_value_error_constructor&lt;A1, A2, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit inplace value or error constructor. Delegates to an appropriate explicit inplace constructor depending on input.\nRequires: predicate::enable_inplace_value_error_constructor` is true.\nComplexity: Same as for the value_type or error_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 957 commits   @akrzemi1 37 commits   @menuet 2 commits   @norbertwenzel 1 commits   @vinipsmaker 1 commits   @andoks 1 commits   @catskul 1 commits   @johnthagen 1 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks for Outcome v2 For a second time, Charley Bay stepped up as review manager. Given how much work it was for the v1 review, I can only say thank you.\nAndrzej Krzemienski went far beyond the call of duty in the development of Outcome v2. He wrote the front page, and the start of the tutorial. He thus set the tone, pacing, style and form of the tutorial which I merely continued for the rest of the tutorial. He also volunteered considerable amounts of his time as as primary peer reviewer for the v2 design and implementation, asking many very valuable \u0026ldquo;stupid questions\u0026rdquo; at least one of which caused a major rethink and refactor. If Outcome v2 passes its second peer review, it\u0026rsquo;s because of Andrzej. Thank you.\nJonathan M√ºller invested countless hours in his doxygen replacement tool Standardese which Outcome uses to generate the reference API docs, and a not insignificant number of those went on fixing issues for Outcome. Thank you.\nSpecial thanks for Outcome v1 To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tags/adl-bridging/",
	"title": "Adl Bridging",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/assignment/",
	"title": "Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/backtrace/",
	"title": "Backtrace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/template/",
	"title": "Constrained template macros",
	"tags": [],
	"description": "",
	"content": "Overridable: All of the following macros are overridable, define before inclusion.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\nThese macros expand into either the syntax for directly specifying constrained templates in C++ 20, or into a SFINAE based emulation for earlier C++ versions. Form of usage looks as follows:\nOUTCOME_TEMPLATE(classErrorCondEnum) OUTCOME_TREQUIRES( // If this is a valid expression  OUTCOME_TEXPR(error_type(make_error_code(ErrorCondEnum()))), // If this predicate is true  OUTCOME_TPRED(predicate::template enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;) // Any additional requirements follow here ...  ) constexpr basic_result(ErrorCondEnum \u0026amp;\u0026amp;t, error_condition_converting_constructor_tag /*unused*/ = {});  Be aware that slightly different semantics occur for real C++ 20 constrained templates than for the SFINAE emulation.\n OUTCOME_TEMPLATE(template args ...)\nBegins a constrained template declaration.\n OUTCOME_TREQUIRES(requirements ...)\nSpecifies the requirements for the constrained template to be available for selection by the compiler.\n OUTCOME_TEXPR(expression)\nA requirement that the given expression is valid.\n OUTCOME_TPRED(boolean)\nA requirement that the given constant time expression is true.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tags/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/converting-constructors/",
	"title": "Converting Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/copy-assignment/",
	"title": "Copy Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/copy-constructors/",
	"title": "Copy Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/default-actions/",
	"title": "Default Actions",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/default-constructors/",
	"title": "Default Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/destructors/",
	"title": "Destructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/disabling-constructors/",
	"title": "Disabling Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/dual-api/",
	"title": "Dual Api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/error/",
	"title": "Error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/exception/",
	"title": "Exception",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/explicit-constructors/",
	"title": "Explicit Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/has_error_code/",
	"title": "Has_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.1 library Outcome is a set of tools for reporting and handling function failures in contexts where using C++ exception handling is unsuitable. Such contexts include:\n programs, or parts thereof, that are compiled with exceptions disabled;\n parts of program that have a lot of branches depending on types of failures, where if-statements are cleaner than try-catch blocks;\n requirement that failure path of execution should not cost more than the successful path of execution;\n situations, like in filesystem library, where the decision whether the failure should be handled remotely (use exceptions) or locally cannot be made inside the function and needs to be moved onto the caller, and in the latter case launching stack unwinding is not desirable for the aforementioned reasons;\n parts of the programs/frameworks that themselves implement exception handling and prefer to not use exceptions to propagate failure reports across thread, tasks, fibers;\n propagating exceptions trough layers that do not implement exception throw safety;\n external requirement (such as company-wide policy) that failure handling paths are explicitly indicated in the code.\n  Outcome addresses failure handling through returning a special type from functions, which is able to store either a successfully computed value (or void) or the information about failure. Outcome also comes with a set of idioms for dealing with such types.\nSample usage One of the tools in the Outcome library is result\u0026lt;T\u0026gt;: it represents either a successfully computed value of type T or an std::error_code representing the reason for failure. You use it in the function\u0026rsquo;s return type:\nauto read_data_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;string\u0026gt;; View this code on Github It is possible to inspect the state manually:\nif (auto rslt = read_data_from_file(\u0026#34;config.cfg\u0026#34;)) use_string(rslt.value()); // returns string else throw LibError{rslt.error(), \u0026#34;config.cfg\u0026#34;}; // returns error_code View this code on Github Or, if this function is called in another function that also returns result\u0026lt;T\u0026gt; you can use a dedicated control statement:\nauto process(const string\u0026amp; content) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;; auto get_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; { OUTCOME_TRY(str, read_data_from_file(path)); // if control gets here read_data_from_file() has succeeded  return process(str); // decltype(str) == string } View this code on Github OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; object contains an error information, the enclosing function is immediately returned with result\u0026lt;U\u0026gt; containing the same failure information; otherwise an automatic object of type T is available in scope.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library has successfully passed the second Boost peer review, and is currently expected to become part of the Boost official release distribution before the 1.70 release (Spring 2019).\n "
},
{
	"uri": "https://ned14.github.io/outcome/tags/hooks/",
	"title": "Hooks",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/implicit-constructors/",
	"title": "Implicit Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/inplace-constructors/",
	"title": "Inplace Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/make_error_code/",
	"title": "Make_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/move-assignment/",
	"title": "Move Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/move-constructors/",
	"title": "Move Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/namespace/",
	"title": "Namespace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/nodiscard/",
	"title": "Nodiscard",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/operators/",
	"title": "Operators",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/outcome/",
	"title": "Outcome",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/payload/",
	"title": "Payload",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/try/",
	"title": "Try",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value/",
	"title": "Value",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value-or-error/",
	"title": "Value or Error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/version/",
	"title": "Version macros",
	"tags": [],
	"description": "",
	"content": "Overridable: None of the following macros are overridable.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n OUTCOME_VERSION_MAJOR \u0026lt;number\u0026gt;\nMajor version for cmake and DLL version stamping.\n OUTCOME_VERSION_MINOR \u0026lt;number\u0026gt;\nMinor version for cmake and DLL version stamping.\n OUTCOME_VERSION_PATCH \u0026lt;number\u0026gt;\nPatch version for cmake and DLL version stamping.\n OUTCOME_VERSION_REVISION \u0026lt;number\u0026gt;\nRevision version for cmake and DLL version stamping.\n OUTCOME_UNSTABLE_VERSION \u0026lt;number\u0026gt;\nDefined between stable releases of Outcome. It means the inline namespace will be permuted per-commit to ensure ABI uniqueness such that multiple versions of Outcome in a single process space cannot collide.\n OUTCOME_V2 \u0026lt;tokens\u0026gt;\nThe namespace configuration of this Outcome v2. Consists of a sequence of bracketed tokens later fused by the preprocessor into namespace and C++ module names.\n OUTCOME_V2_NAMESPACE \u0026lt;identifier\u0026gt;\nThe Outcome namespace, which may be permuted per SHA commit. This is not fully qualified.\n OUTCOME_V2_NAMESPACE_BEGIN \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to enter the Outcome v2 namespace.\n OUTCOME_V2_NAMESPACE_EXPORT_BEGIN \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to enter the C++ module exported Outcome v2 namespace.\n OUTCOME_V2_NAMESPACE_END \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to exit the Outcome v2 namespace.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/disable_execinfo/",
	"title": "`OUTCOME_DISABLE_EXECINFO`",
	"tags": [],
	"description": "If defined, disables the use of the `&lt;execinfo.h&gt;` header (or the win32 emulation).",
	"content": "If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\nSome embedded Linux toolchains do not define \u0026lt;execinfo.h\u0026gt;, thus disabling C++ exceptions on those toolchains produces a failure to find this file. Avoid that problem by defining this macro to disable stack backtrace support entirely.\nOverridable: Define before inclusion.\nDefault: Defined if __ANDROID__ is defined, else undefined.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/nodiscard/",
	"title": "`OUTCOME_NODISCARD`",
	"tags": [],
	"description": "How to tell the compiler than the return value of a function should not be discarded without examining it.",
	"content": "Compiler-specific markup used to tell the compiler than the return value of a function should not be discarded without examining it.\nOverridable: Define before inclusion.\nDefault: To [[nodiscard]] if on C++ 17 or higher, __attribute__((warn_unused_result)) if on clang, SAL _Must_inspect_result_ if on MSVC, otherwise nothing.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/requires/",
	"title": "`OUTCOME_REQUIRES(...)`",
	"tags": [],
	"description": "A C++ 20 `requires(...)`, if available.",
	"content": "A C++ 20 requires(...), if available.\nOverridable: Define before inclusion.\nDefault: To requires(...) if on C++ 20 or later, else to nothing.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/symbol_visible/",
	"title": "`OUTCOME_SYMBOL_VISIBLE`",
	"tags": [],
	"description": "How to mark throwable types as always having default ELF symbol visibility.",
	"content": "Compiler-specific markup used to mark throwable types as always having default ELF symbol visibility, without which it will be impossible to catch throws of such types across shared library boundaries on ELF only.\nOverridable: Define before inclusion.\nDefault: Standalone Outcome: To __attribute__((visibility(\u0026quot;default\u0026quot;)) on GCC and clang when targeting ELF, otherwise nothing. Boost.Outcome: To BOOST_SYMBOL_VISIBLE. \nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/thread_local/",
	"title": "`OUTCOME_THREAD_LOCAL`",
	"tags": [],
	"description": "How to mark variables as having thread local storage duration.",
	"content": "Compiler-specific markup used to mark variables as having thread local storage duration.\nThis isn\u0026rsquo;t used inside Outcome, but is used by its unit test suite.\n Overridable: Define before inclusion.\nDefault: To thread_local if the compiler implements C++ 11 thread_local, else __thread for the one supported compiler (older Mac OS XCode) which does not.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/throw_exception/",
	"title": "`OUTCOME_THROW_EXCEPTION(expr)`",
	"tags": [],
	"description": "How to throw a C++ exception, or equivalent thereof.",
	"content": "Throws a C++ exception, or equivalent thereof.\nOverridable: Define before inclusion.\nDefault: Standalone Outcome (C++ exceptions enabled): To throw expr Standalone Outcome (C++ exceptions disabled): To OUTCOME_V2_NAMESPACE::detail::do_fatal_exit(#expr) which is a function which prints a useful error message including a stack backtrace (where available) to stderr before calling abort(). Boost.Outcome: To BOOST_THROW_EXCEPTION(expr). \nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/try/",
	"title": "`OUTCOME_TRY(var, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in a type matching the `ValueOrError&lt;T, E&gt;` concept, assigning `T` to a variable called `var` if successful, immediately returning `E` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, assigning T to a variable called var if successful, immediately returning E from the calling function if unsuccessful.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nIf successful, an auto \u0026amp;\u0026amp;var is initialised to the expression result\u0026rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryv/",
	"title": "`OUTCOME_TRYV(expr)/OUTCOME_TRY(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in a type matching the `ValueOrError&lt;void, E&gt;` concept, continuing execution if successful, immediately returning `E` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, continuing execution if successful, immediately returning E from the calling function if unsuccessful.\nThe difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr)). The former requires the T to be void.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, auto \u0026amp;\u0026amp;. If that reference\u0026rsquo;s bound object\u0026rsquo;s .has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\ntry_operation_return_as(expr) is a customisation point, the default implementation of which returns a API NOT FOUND IN DOCS failure\u0026lt;E\u0026gt; for Outcome types, or an  P0323 std::unexpected\u0026lt;E\u0026gt; for Expected types.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryx/",
	"title": "`OUTCOME_TRYX(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in a type matching the `ValueOrError&lt;T, E&gt;` concept, emitting the `T` if successful, immediately returning `E` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the ValueOrError\u0026lt;T, E\u0026gt; concept, emitting the T if successful, immediately returning E from the calling function if unsuccessful.\nAvailability: GCC and clang only. Use #ifdef OUTCOME_TRYX to determine if available.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nThis macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_TRYX(expr) directly in expressions e.g. auto x = y + OUTCOME_TRYX(foo(z));.\nBe aware there are compiler quirks in preserving the rvalue/lvalue/etc-ness of emitted T\u0026rsquo;s, specifically copy or move constructors may be called unexpectedly and/or copy elision not work as expected. If these prove to be problematic, use OUTCOME_TRY(var, expr) instead.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/valueorerror/",
	"title": "`ValueOrError&lt;T, E&gt;`",
	"tags": [],
	"description": "A boolean concept matching types with either a value or an error.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, a public .value() observer function, and a public .error() observer function.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches expected-like types such as  P0323 std::expected\u0026lt;T, E\u0026gt;, one of which is basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;. Be aware it does not differentiate between value-or-error types and value-and-error types if they present the interface matched above.\nNamespace: OUTCOME_V2_NAMESPACE::convert\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/valueornone/",
	"title": "`ValueOrNone&lt;T&gt;`",
	"tags": [],
	"description": "A boolean concept matching types with an optional value.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, and a public .value() observer function.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches optional-like types such as  std::optional\u0026lt;T\u0026gt;. Note it also matches  P0323 std::expected\u0026lt;T, E\u0026gt;, which also has an optional-like interface. You may thus wish to preferentially match ValueOrError\u0026lt;T, E\u0026gt; for any given T.\nNamespace: OUTCOME_V2_NAMESPACE::convert\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/",
	"title": "`basic_result&lt;T, E, NoValuePolicy&gt;`",
	"tags": [],
	"description": "A sum type carrying either a successful `T`, or a disappointment `E`, with `NoValuePolicy` specifying what to do if one tries to read state which isn&#39;t there.",
	"content": " A sum type carrying either a T or an E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there. Either or both of T and E can be void to indicate no value for that state is present.\nRequires: Concept requirements if C++ 20, else static asserted:\n That trait type_can_be_used_in_basic_result\u0026lt;R\u0026gt; is true for both T and E. That either E is void or DefaultConstructible.  Namespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\nInclusions: The very lightest weight of C and C++ header files:\n \u0026lt;cstdint\u0026gt; \u0026lt;initializer_list\u0026gt; \u0026lt;iosfwd\u0026gt; \u0026lt;new\u0026gt; \u0026lt;type_traits\u0026gt; \u0026lt;utility\u0026gt; (C++ 17 or later only, for  std::in_place_type_t\u0026lt;T\u0026gt;) If C++ exceptions disabled and OUTCOME_DISABLE_EXECINFO undefined only (used to print stack backtraces on \u0026ldquo;exception throw\u0026rdquo;):  \u0026lt;sal.h\u0026gt; (Windows only) \u0026lt;stddef.h\u0026gt; (Windows only) \u0026lt;string.h\u0026gt; (Windows only) \u0026lt;execinfo.h\u0026gt; (POSIX only)  \u0026lt;cstdio\u0026gt; \u0026lt;cstdlib\u0026gt; \u0026lt;cassert\u0026gt;  This very light weight inclusion dependencies makes basic result suitable for use in global header files of very large C++ codebases.\nDesign rationale The basic result type is the main workhorse type of the Outcome library, providing a simple sum type with optional values representing success or disappointment. Unlike  P0323 std::expected\u0026lt;T, E\u0026gt;, Outcome\u0026rsquo;s result type is designed specifically for convenience when implementing failure handling, and it has a number of API differences to facilitate that.\nThe first major design difference is that basic result models its constructor design on  std::variant\u0026lt;...\u0026gt;, rather than modelling  std::optional\u0026lt;T\u0026gt;\u0026rsquo;s constructor design like std::expected\u0026lt;T, E\u0026gt; does. This means that basic result will implicitly construct either a T or an E if doing so is unambiguous, same as variant does. Where implicit construction is ambiguous, the implicit constructors disable and a T or E can be specified via in_place_type_t\u0026lt;T\u0026gt;, or via API NOT FOUND IN DOCS success_type\u0026lt;T\u0026gt; or API NOT FOUND IN DOCS failure_type\u0026lt;T\u0026gt;.\nThe second major design difference is that union storage is NOT used, as it is assumed that sizeof(E) will be small for failure handling. This very considerably reduces load on the compiler, and substantially improves compile times in very large C++ codebases.\nPublic member type aliases  value_type is T. error_type is E. value_type_if_enabled is T if construction from T is available, else it is a usefully named unusable internal type. error_type_if_enabled is E if construction from T is available, else it is a usefully named unusable internal type. rebind\u0026lt;A, B = E, C = NoValuePolicy\u0026gt; is basic_result\u0026lt;A, B, C\u0026gt;.  Protected member predicate booleans  predicate::constructors_enabled is constexpr boolean true if decayed value_type and decayed error_type are not the same type.\n predicate::implicit_constructors_enabled is constexpr boolean true if:\n predicate::constructors_enabled is true. Trait is_error_type\u0026lt;E\u0026gt; is not true for both decayed value_type and decayed error_type at the same time. value_type is not implicitly constructible from error_type and error_type is not implicitly constructible from value_type.\nOR\ntrait is_error_type\u0026lt;E\u0026gt; is true for decayed error_type and error_type is not implicitly constructible from value_type and value_type is an integral type.  predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed R is not this basic_result type. Decayed R is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed R. value_type is implicitly constructible from R and error_type is not implicitly constructible from R.\nOR\nvalue_type is the exact same type as decayed R and value_type is implicitly constructible from R.  predicate::enable_error_converting_constructor\u0026lt;R\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed R is not this basic_result type. Decayed R is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed R. value_type is not implicitly constructible from R and error_type is implicitly constructible from R.\nOR\nerror_type is the exact same type as decayed R and error_type is implicitly constructible from R.  predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed ErrorCondEnum is not this basic_result type. Decayed ErrorCondEnum is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is true for error_type and decayed ErrorCondEnum.  predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_result\u0026lt;R, S, P\u0026gt; is not this basic_result type. R is void OR value_type is explicitly constructible from R. S is void OR error_type is explicitly constructible from S.  predicate::enable_inplace_value_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. value_type is void OR value_type is explicitly constructible from Args....  predicate::enable_inplace_error_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. error_type is void OR error_type is explicitly constructible from Args....  predicate::enable_inplace_value_error_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Either, but not both, of value_type is explicitly constructible from Args... or error_type is explicitly constructible from Args....   Public member functions Disabling constructors  basic_result(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_result(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n Regular member functions  basic_result() = delete The default constructor (disabled).\n basic_result(basic_result \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_result(const basic_result \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(basic_result \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(const basic_result \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_result() Destructor. Constexpr, triviality and noexcept propagating.\n Converting constructors  basic_result(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(ValueOrError\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from ValueOrError\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Inplace constructors  explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error constructor. Available if predicate::enable_inplace_value_error_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n "
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/has_error_code/",
	"title": "`has_error_code&lt;T&gt;`",
	"tags": [],
	"description": "True if an error code can be constructed from a `T`.",
	"content": "True if an error code can be constructed from a T e.g. if there exists an ADL discovered free function make_error_code(T) and it returns an error code.\nOverridable: By template specialisation into the trait namespace.\nDefault: True if T is implicitly constructible to an error code, else to metaprogramming which performs the ADL discovery and testing of the result type of make_error_code(T). Note that the STL defines multiple overloads of an ADL discovered free function  std::make_error_code(T) for its error enumerations, as does Boost.System for the Boost error enumerations. Thus this trait will pick up those free functions for those error types.\nNamespace: OUTCOME_V2_NAMESPACE::trait\nHeader: Declared by \u0026lt;outcome/trait.hpp\u0026gt;, defined by \u0026lt;outcome/std_result.hpp\u0026gt;.\nVariable alias: has_error_code_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/has_exception_ptr/",
	"title": "`has_exception_ptr&lt;T&gt;`",
	"tags": [],
	"description": "True if an exception ptr can be constructed from a `T`.",
	"content": "True if an exception ptr can be constructed from a T e.g. if there exists an ADL discovered free function make_exception_ptr(T) and it returns an exception ptr.\nOverridable: By template specialisation into the trait namespace.\nDefault: True if T is implicitly constructible to an exception ptr, else to metaprogramming which performs the ADL discovery and testing of the result type of make_exception_ptr(T). Note that the STL defines an ADL discovered free function  std::make_exception_ptr(T). Thus this trait will pick up that free function.\nNamespace: OUTCOME_V2_NAMESPACE::trait\nHeader: Declared by \u0026lt;outcome/trait.hpp\u0026gt;, defined by \u0026lt;outcome/std_result.hpp\u0026gt;.\nVariable alias: has_exception_ptr_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/in_place_type_t/",
	"title": "`in_place_type_t&lt;T&gt;`",
	"tags": [],
	"description": "Either `std::in_place_type_t&lt;T&gt;` if C++ 17 or later, else a local emulation.",
	"content": "Either std::in_place_type_t\u0026lt;T\u0026gt; if C++ 17 or later, else a local emulation.\nNote that the templated variable in_place_type is also aliased or emulated locally.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\nInclusions: \u0026lt;utility\u0026gt; if C++ 17 or later only, for  std::in_place_type_t\u0026lt;T\u0026gt;.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_basic_result/",
	"title": "`is_basic_result&lt;T&gt;`",
	"tags": [],
	"description": "An integral constant type true for `basic_result&lt;T, E, NoValuePolicy&gt; types.",
	"content": "An integral constant type true for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; types.\nOverridable: Not overridable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\nVariable alias: is_basic_result_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_error_type/",
	"title": "`is_error_type&lt;E&gt;`",
	"tags": [],
	"description": "A customisable integral constant type true for `E` types which are to receive error throwing no-value policies.",
	"content": "A customisable integral constant type true for E types which are to receive error throwing no-value policies.\nOverridable: By template specialisation into the trait namespace.\nDefault: False. Specialisations to true exist for:\n \u0026lt;outcome/boost_result.hpp\u0026gt;\n boost::system::error_code boost::system::errc::errc_t boost::exception_ptr  \u0026lt;outcome/std_result.hpp\u0026gt;\n std::error_code std::errc std::exception_ptr   Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_error_type_enum/",
	"title": "`is_error_type_enum&lt;E, Enum&gt;`",
	"tags": [],
	"description": "A customisable integral constant type true for `E` types constructible from `Enum` types which are to receive error throwing no-value policies.",
	"content": "A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies\nOverridable: By template specialisation into the trait namespace.\nDefault: False. Specialisations exist for:\n \u0026lt;outcome/boost_result.hpp\u0026gt;\n boost::system::error_code to boost::system::is_error_condition_enum\u0026lt;Enum\u0026gt;::value.  \u0026lt;outcome/std_result.hpp\u0026gt;\n std::error_code to std::is_error_condition_enum\u0026lt;Enum\u0026gt;::value.   Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/converters/try_operation_return_as/",
	"title": "`try_operation_return_as(expr)`",
	"tags": [],
	"description": "A customisable converter of `ValueOrError&lt;T, E&gt;` concept matching types to a returnable failure type.",
	"content": "A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types to a returnable failure type.\nOverridable: By template specialisation into the OUTCOME_V2_NAMESPACE namespace.\nDefault: A number of overloads are provided by default:\n try_operation_return_as(T \u0026amp;\u0026amp;) which requires T to provide an .as_failure() member function in order to be available. This is selected for all basic_result and basic_outcome types.\n Copy and move editions of try_operation_return_as(std::experimental::expected\u0026lt;T, E\u0026gt;) which return a std::experimental::unexpected\u0026lt;E\u0026gt; for the input\u0026rsquo;s .error() member function.\n  Namespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/",
	"title": "`type_can_be_used_in_basic_result&lt;R&gt;`",
	"tags": [],
	"description": "A constexpr boolean true for types permissible in `basic_result&lt;T, E, NoValuePolicy&gt;`.",
	"content": "A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\nOverridable: Not overridable.\nDefinition: True for a type which:\n Is not a reference. Is not an in_place_type_t\u0026lt;T\u0026gt;. Is not a API NOT FOUND IN DOCS success_type\u0026lt;T\u0026gt;. Is not a API NOT FOUND IN DOCS failure_type\u0026lt;E, P\u0026gt;. Is not an array. Is either void, or else is an Object and is Destructible.  Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/converters/value_or_error/",
	"title": "`value_or_error&lt;T, U&gt;`",
	"tags": [],
	"description": "A customisable converter of `ValueOrError&lt;T, E&gt;` concept matching types.",
	"content": "A customisable converter of ValueOrError\u0026lt;T, E\u0026gt; concept matching types. It must have the following form:\n// `T` will be the destination basic_result or basic_outcome. // `U` will be the decayed form of the `ValueOrError\u0026lt;T, E\u0026gt;` concept matching input type. template \u0026lt;classT\u0026gt; struct value_or_error\u0026lt;T, U\u0026gt; { // False to indicate that this converter wants `basic_result`/`basic_outcome` to reject all other `basic_result`  static constexpr bool enable_result_inputs = false; // False to indicate that this converter wants `basic_outcome` to reject all other `basic_outcome`  static constexpr bool enable_outcome_inputs = false; // `X` will be the raw input form of `U`. It must return a `T`.  template\u0026lt;classX\u0026gt; constexpr T operator()(X \u0026amp;\u0026amp;v); };  Overridable: By template specialisation into the convert namespace.\nDefault: If decayed X is same as U, concept ValueOrError\u0026lt;U\u0026gt; matches, X::value_type is void or is explicitly constructible to T::value_type, and X::error_type is void or is explicitly constructible to T::error_type, then operator()(X \u0026amp;\u0026amp;) is made available.\noperator()(X \u0026amp;\u0026amp;v) tests if v.has_value() is true, if so then a T with successful value is returned, else a T with unsuccessful value. If the input type was void, a default constructed value is used for either, else a move/copy construction from the source is performed.\nNamespace: OUTCOME_V2_NAMESPACE::convert\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\n"
}]