<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/</link>
    <description>Recent content in Home on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 10 Dec 2018 20:32:00 +0000</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Incommensurate E types</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/problem/</guid>
      <description>Back in the tutorial section on Default Actions, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now set E = std::error_code as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.</description>
    </item>
    
    <item>
      <title>ValueOrError Concept</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/value-or-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/value-or-error/</guid>
      <description>Something not really mentioned until now is how Outcome interoperates with the proposed std::expected&amp;lt;T, E&amp;gt;, whose design lands in between outcome::unchecked&amp;lt;T, E&amp;gt; and outcome::checked&amp;lt;T, E&amp;gt;, both of which are simplified aliases for outcome::result&amp;lt;T, E&amp;gt; hard coding the NoValuePolicy to a fixed policy.
Expected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.</description>
    </item>
    
    <item>
      <title>A custom no-value policy</title>
      <link>https://ned14.github.io/outcome/tutorial/no-value/custom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/no-value/custom/</guid>
      <description>If you want your basic_outcome&amp;lt;&amp;gt; or basic_result&amp;lt;&amp;gt; instances to call std::abort() whenever .value() is called on an object that does not contain a value, or .error() is called on an object that does not contain an error, you will need to define your own no-value policy as follows:
struct abort_policy : outcome::policy::base { template &amp;lt;classImpl&amp;gt; static constexpr void wide_value_check(const Impl&amp;amp; self) { if (!base::_has_value(self)) std::abort(); } template &amp;lt;classImpl&amp;gt; static constexpr void wide_error_check(const Impl&amp;amp; self) { if (!</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://ned14.github.io/outcome/motivation/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/exceptions/</guid>
      <description>Exceptions Exceptions are the default mechanism in C++ for reporting, propagating and processing the information about function failures. Their main advantage is the ability to describe the &amp;ldquo;success dependency&amp;rdquo; between functions: if you want to say that calling function g() depends on the successful execution of function f(), you just put g() below f() and that&amp;rsquo;s it:
int a() { f(); g(); // don&amp;#39;t call g() and further if f() fails  return h(); // don&amp;#39;t call h() if g() fails }  In the C++ Standard terms this means that f() is sequenced before g().</description>
    </item>
    
    <item>
      <title>Keeping state</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/keeping_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/keeping_state/</guid>
      <description>The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result&amp;lt;T, std::pair&amp;lt;error_code, std::unique_ptr&amp;lt;stack_backtrace&amp;gt;&amp;gt;&amp;gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.
We therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/limitations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/limitations/</guid>
      <description>C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:
 A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should be annotated with extern &amp;quot;C&amp;quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI.</description>
    </item>
    
    <item>
      <title>The Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file/</guid>
      <description>Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.
Consider the copy_file() API from the Filesystem TS:
namespace filesystem { /*! Copies the file at path `from` to path `to`. \returns True if file was successfully copied. \throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path &amp;amp;from, const path &amp;amp;to); /*!</description>
    </item>
    
    <item>
      <title>The HTTP library</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/httplib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/httplib/</guid>
      <description>Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.
Let us imagine that the HTTP library has the following public interface:
// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum classstatus_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library  template &amp;lt;classT&amp;gt; using result = OUTCOME_V2_NAMESPACE::result&amp;lt;T, failure&amp;gt;; /* Performs a HTTP GET on the url, returning the body if successful, a failure with status_code if unsuccessful at the HTTP level, or a C++ exception throw if something catastrophic happened e.</description>
    </item>
    
    <item>
      <title>Two phase construction</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/two-phase-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/two-phase-init/</guid>
      <description>The first thing to do is to break your object&amp;rsquo;s construction into two phases:
 Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1.</description>
    </item>
    
    <item>
      <title>The HTMLTidy library</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/tidylib/</guid>
      <description>// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool, I highly recommend it.  // This isn&amp;#39;t the API for Tidy, but let&amp;#39;s assume it&amp;#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern &amp;#34;C&amp;#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a &amp;ldquo;split&amp;rdquo; T|E API.</description>
    </item>
    
    <item>
      <title>A file handle</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/file_handle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/file_handle/</guid>
      <description>Borrowing from afio::file_handle which uses this design pattern, here is a simplified file_handle implementation:
classfile_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum classmode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!</description>
    </item>
    
    <item>
      <title>ADL bridging</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/</guid>
      <description>In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered API NOT FOUND IN DOCS success_failure/#standardese-outcome_v2_xxx__policy__throw_as_system_error_with_payload-Error--Errorconst-- function was to be found.
Here we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.
namespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn&amp;#39;t trigger the ADL bridge.</description>
    </item>
    
    <item>
      <title>Built-in policies</title>
      <link>https://ned14.github.io/outcome/tutorial/no-value/builtin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/no-value/builtin/</guid>
      <description>These are the predefined policies built into Outcome:
API NOT FOUND IN DOCS policies/all_narrow If there is an observation of a value/error/exception which is not present, the behavior is undefined. However this is a tool-friendly UB using intrinsics such as __builtin_unreachable() that allows tool to make use of it, e.g., better bug detection or optimizations.
API NOT FOUND IN DOCS policies/terminate Observation of a missing value/error/exception causes the call to std::terminate().</description>
    </item>
    
    <item>
      <title>Example C&#43;&#43; function</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/example/</guid>
      <description>Let us start with a simple C++ function which we wish to make available to C code:
// Fill the supplied buffer with the integer v converted to a string, returning // length of string minus null terminator extern &amp;#34;C&amp;#34; outcome::result&amp;lt;size_t&amp;gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.size() + 1 &amp;gt; bufferlen) return std::errc::no_buffer_space; // Copy the string into the supplied buffer, and return length of string  memcpy(buffer, temp.</description>
    </item>
    
    <item>
      <title>Inspecting result&lt;T, EC&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/result/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/result/inspecting/</guid>
      <description>Suppose we will be writing a function print_half that takes an integer number (however big) represented as an std::string and outputs a number which is twice smaller:
outcome::result&amp;lt;void&amp;gt; print_half(const std::string&amp;amp; text); View this code on Github The type result&amp;lt;void&amp;gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result&amp;lt;&amp;gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).</description>
    </item>
    
    <item>
      <title>The File I/O library</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/filelib/</guid>
      <description>The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:
// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.</description>
    </item>
    
    <item>
      <title>Upgrading the Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file2/</guid>
      <description>An Outcome based solution to the dual overload problem is straightforward:
namespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace.</description>
    </item>
    
    <item>
      <title>errno</title>
      <link>https://ned14.github.io/outcome/motivation/errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/errno/</guid>
      <description>errno The idiom of returning, upon failure, a special value and storing an error code (an int) inside a global (or thread-local) object errno is inherited from C, and used in its Standard Library:
int readValue(const char * filename) { FILE* f = fopen(filename, &amp;#34;r&amp;#34;); if (f == NULL) return 0; // special value indicating failure  // keep errno value set by fopen()  int i; int r = fscanf(f, &amp;#34;%d&amp;#34;, &amp;amp;i); if (r == 0 || r == EOF) { // special values: i not read  errno = ENODATA; // choose error value to return  return 0; fclose(f); errno = 0; // clear error info (success)  return i; }  One advantage (to some and a disadvantage to others) of this technique is that it uses familiar control statements (if and return) to indicate all execution paths that handle failures.</description>
    </item>
    
    <item>
      <title>The Application</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app/</guid>
      <description>The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.
// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template &amp;lt;classT&amp;gt; using outcome = OUTCOME_V2_NAMESPACE::outcome&amp;lt;T, error_code /*, std::exception_ptr */&amp;gt;; using OUTCOME_V2_NAMESPACE::success; } View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.</description>
    </item>
    
    <item>
      <title>Auto-throwing filesystem_error</title>
      <link>https://ned14.github.io/outcome/tutorial/payload/copy_file3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/payload/copy_file3/</guid>
      <description>Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.
Seeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.</description>
    </item>
    
    <item>
      <title>Calling it from C</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/example2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/example2/</guid>
      <description>Now let us call our result returning C++ function from C:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // for strerror// This header in Outcome is pure C, it provides a suite of C helper macros #include &amp;#34;../../../include/outcome/result.h&amp;#34; // Declare our C++ function&amp;#39;s returning result type. Only needs to be done once. CXX_DECLARE_RESULT_EC(size_t, size_t); // Tell C about our C++ function extern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v); void print(int v) { char buffer[4]; CXX_RESULT_EC(size_t) res; res = to_string(buffer, sizeof(buffer), v); if(CXX_RESULT_HAS_VALUE(res)) { printf(&amp;#34;to_string(%d) fills buffer with &amp;#39;%s&amp;#39; of %zu characters\n&amp;#34;, v, buffer, res.</description>
    </item>
    
    <item>
      <title>Error codes</title>
      <link>https://ned14.github.io/outcome/motivation/error_codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/error_codes/</guid>
      <description>Error codes Error codes are reasonable error handling technique, also working in C. In this case the information is also stored as an int, but returned by value, which makes it possible to make functions pure (side-effect-free and referentially transparent).
int readInt(const char * filename, int&amp;amp; val) { FILE* fd; int r = openFile(filename, /*out*/ fd); if (r != 0) return r; // return whatever error openFile() returned  r = readInt(fd, /*out*/ val); if (r !</description>
    </item>
    
    <item>
      <title>Hook result</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/hook_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/hook_result/</guid>
      <description>We now tell Outcome that for every instance of our localised result&amp;lt;T&amp;gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.
namespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.</description>
    </item>
    
    <item>
      <title>Inspecting outcome&lt;T, EC, EP&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/outcome/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/outcome/inspecting/</guid>
      <description>Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome&amp;lt;int&amp;gt; (which may store a double or an std::error_code or an std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_code&amp;rsquo;s:</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application 1/2</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app-map-httplib1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app-map-httplib1/</guid>
      <description>Firstly we are going to need to wrap up httplib::failure into a custom STL exception type before we can type erase it into an exception_ptr instance. Please note that this code is defined in the app namespace:
namespace app { // Specialise an exception type for httplib errors  struct httplib_error : std::runtime_error { // passthrough  using std::runtime_error::runtime_error; httplib_error(httplib::failure _failure, std::string msg) : std::runtime_error(std::move(msg)) , failure(std::move(_failure)) { } // the original failure  httplib::failure failure; }; // Type erase httplib::result&amp;lt;U&amp;gt; into a httplib_error exception ptr  template &amp;lt;classU&amp;gt; inline std::exception_ptr make_httplib_exception(const httplib::result&amp;lt;U&amp;gt; &amp;amp;src) { std::string str(&amp;#34;httplib failed with error &amp;#34;); switch(src.</description>
    </item>
    
    <item>
      <title>Phase 2 construction</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/static-constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/static-constructor/</guid>
      <description>Its phase 2 constructor:
// Phase 2 static member constructor function, which cannot throw inline outcome::result&amp;lt;file_handle&amp;gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret.</description>
    </item>
    
    <item>
      <title>TRY operations</title>
      <link>https://ned14.github.io/outcome/tutorial/result/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/result/try/</guid>
      <description>In the implementation of function print_half we have seen the usage of the macro API NOT FOUND IN DOCS try:
OUTCOME_TRY (i, BigInt::fromString(text));  The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i,, the control statement is roughly equivalent to:
auto&amp;amp;&amp;amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure();  Where __result is a compile time generated unique name.</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application 2/2</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app-map-httplib2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app-map-httplib2/</guid>
      <description>If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from httplib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, httplib::result&amp;lt;U&amp;gt;&amp;gt; { // False to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;httplib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.</description>
    </item>
    
    <item>
      <title>Custom exception ptr</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/poke_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/poke_exception/</guid>
      <description>If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.
But let&amp;rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:</description>
    </item>
    
    <item>
      <title>Mapping the File I/O library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app-map-filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app-map-filelib/</guid>
      <description>To handle the File I/O library, once again we turn to custom ValueOrError converters:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, filelib::result&amp;lt;U&amp;gt;&amp;gt; { // True to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;filelib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value  if(src.</description>
    </item>
    
    <item>
      <title>Phase 3</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg1/</guid>
      <description>We have built our first two phases of construction for file_handle, and for some users they might be happy writing:
outcome::result&amp;lt;file_handle&amp;gt; fh1 = file_handle::file(&amp;#34;hello&amp;#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr &amp;lt;&amp;lt; &amp;#34;Opening file &amp;#39;hello&amp;#39; failed with &amp;#34; &amp;lt;&amp;lt; fh1.error().message() &amp;lt;&amp;lt; std::endl; } View this code on Github &amp;hellip; and be done with it.
But wouldn&amp;rsquo;t it be nicer if we could instead write:
outcome::result&amp;lt;file_handle&amp;gt; fh2 = construct&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34; /*, file_handle::mode::read */}(); if(!</description>
    </item>
    
    <item>
      <title>Variations</title>
      <link>https://ned14.github.io/outcome/tutorial/c-api/variations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/c-api/variations/</guid>
      <description>You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with API NOT FOUND IN DOCS result_c/#standardese-CXX_DECLARE_RESULT, refer to it with API NOT FOUND IN DOCS result_c/#standardese-CXX_RESULT and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =
struct cxx_error_code { int code; void *category; }; &amp;hellip; which is declared for you by result.</description>
    </item>
    
    <item>
      <title>std::error_code</title>
      <link>https://ned14.github.io/outcome/motivation/std_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/std_error_code/</guid>
      <description>std::error_code Type std::error_code has been designed to be sufficiently small and trivial to be cheaply passed around, and at the same time be able to store sufficient information to represent any error situation from any library/sub-system in the world without a clash. Its representation is basically:
classerror_code { error_category* domain; // domain from which the error originates  int value; // numeric value of error within the domain };  Here, domain indicates the library from which the error originates.</description>
    </item>
    
    <item>
      <title>Mapping the HTMLTidy library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app-map-tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app-map-tidylib/</guid>
      <description>Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.
namespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.</description>
    </item>
    
    <item>
      <title>Hook outcome</title>
      <link>https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/</guid>
      <description>The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn&amp;rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.</description>
    </item>
    
    <item>
      <title>In use</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/app-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/app-go/</guid>
      <description>This is how you might now write application code using these three libraries:
namespace app { outcome&amp;lt;void&amp;gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result. This makes it explicit what you intend to do as conversion  // may be a lot more expensive than moves.  // Try to GET this URL.</description>
    </item>
    
    <item>
      <title>Plugging a library into std::error_code</title>
      <link>https://ned14.github.io/outcome/motivation/plug_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/plug_error_code/</guid>
      <description>This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title>construct&lt;T&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg2/</guid>
      <description>First, we need a base definition for construct&amp;lt;T&amp;gt;:
template &amp;lt;classT&amp;gt; struct construct { outcome::result&amp;lt;T&amp;gt; operator()() const noexcept { //  static_assert(!std::is_same&amp;lt;T, T&amp;gt;::value, &amp;#34;construct&amp;lt;T&amp;gt;() was not specialised for the type T supplied&amp;#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.
We then specialise for construct&amp;lt;file_handle&amp;gt;:
template &amp;lt;&amp;gt; struct construct&amp;lt;file_handle&amp;gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here .</description>
    </item>
    
    <item>
      <title>Conclusion</title>
      <link>https://ned14.github.io/outcome/tutorial/interop/conclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/interop/conclusion/</guid>
      <description>This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace.
However there are occasions when you don&amp;rsquo;t have control over the implementation of the destination E type e.g. in callbacks.</description>
    </item>
    
    <item>
      <title>Alternatives</title>
      <link>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg3/</guid>
      <description>No doubt many will dislike the two-stage invocation pattern i.e.
construct&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34;}();  So let us examine the most obvious alternative: a templated free function construct&amp;lt;T&amp;gt;.
Due to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.
template&amp;lt;class... Args&amp;gt; inline outcome::result&amp;lt;file_handle&amp;gt; construct(std::in_place_type_t&amp;lt;file_handle&amp;gt;, Args&amp;amp;&amp;amp; ... args) { return file_handle::file(std::forward&amp;lt;Args&amp;gt;(args)...); } ... // Now you must always write this: construct(std::in_place_type&amp;lt;file_handle&amp;gt;, &amp;#34;hello&amp;#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:</description>
    </item>
    
    <item>
      <title>Narrow contracts</title>
      <link>https://ned14.github.io/outcome/motivation/narrow_contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/narrow_contract/</guid>
      <description>A program&amp;rsquo;s thread of execution can enter a &amp;ldquo;disappointing&amp;rdquo; state for two reasons:
 due to disappointing situation in the environment (operating system, external input), or due to a bug in the program.  The key to handling these disappointments correctly is to identify to which category they belong, and use the tools adequate for a given category. In this tutorial when we say &amp;ldquo;error&amp;rdquo; or &amp;ldquo;failure&amp;rdquo; we only refer to the first category.</description>
    </item>
    
    <item>
      <title>`basic_result() = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/default/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/default/</guid>
      <description>The default constructor for basic result is always disabled.</description>
    </item>
    
    <item>
      <title>`basic_result(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</guid>
      <description>Move constructor.
Requires: that value_type and error_type both implement a move constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</guid>
      <description>Copy constructor.
Requires: that value_type and error_type both implement a copy constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</guid>
      <description>Move assignment.
Requires: that value_type and error_type both implement move assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type&amp;rsquo;s move assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</guid>
      <description>Copy assignment.
Requires: that value_type and error_type both implement copy assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type&amp;rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`~basic_result()`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</guid>
      <description>Destructor.
Requires: Always available.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(Args...) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</guid>
      <description>Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.
Requires: predicate::constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(X &amp;&amp;) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</guid>
      <description>Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.
Requires: predicate::implicit_constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(R &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</guid>
      <description>Implicit value_type constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; *, T &amp;amp;&amp;amp;) with this and R.
Requires: predicate::enable_value_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for value_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(S &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</guid>
      <description>Implicit error_type constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; *, T &amp;amp;&amp;amp;) with this and S.
Requires: predicate::enable_error_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(ErrorCondEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</guid>
      <description>Implicit error_type from ErrorCondEnum constructor. Calls API NOT FOUND IN DOCS hook_result_construction(basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; *, T &amp;amp;&amp;amp;) with this and ErrorCondEnum.
Requires: predicate::enable_error_condition_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_header/</guid>
      <description>Outcome 2.0 library documentation</description>
    </item>
    
    <item>
      <title>Acknowledgements</title>
      <link>https://ned14.github.io/outcome/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/credits/</guid>
      <description>github contributors HAHAHUGOSHORTCODE-0xc0002f1400-1-HBHB
This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks for Outcome v2 For a second time, Charley Bay stepped up as review manager. Given how much work it was for the v1 review, I can only say thank you.
Andrzej Krzemienski went far beyond the call of duty in the development of Outcome v2.</description>
    </item>
    
    <item>
      <title>Constrained template macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/template/</guid>
      <description>Overridable: All of the following macros are overridable, define before inclusion.
Header: &amp;lt;outcome/config.hpp&amp;gt;
These macros expand into either the syntax for directly specifying constrained templates in C++ 20, or into a SFINAE based emulation for earlier C++ versions. Form of usage looks as follows:
OUTCOME_TEMPLATE(classErrorCondEnum) OUTCOME_TREQUIRES( // If this is a valid expression  OUTCOME_TEXPR(error_type(make_error_code(ErrorCondEnum()))), // If this predicate is true  OUTCOME_TPRED(predicate::template enable_error_condition_converting_constructor&amp;lt;ErrorCondEnum&amp;gt;) // Any additional requirements follow here .</description>
    </item>
    
    <item>
      <title>Version macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/version/</guid>
      <description>Overridable: None of the following macros are overridable.
Header: &amp;lt;outcome/config.hpp&amp;gt;
 OUTCOME_VERSION_MAJOR &amp;lt;number&amp;gt;
Major version for cmake and DLL version stamping.
 OUTCOME_VERSION_MINOR &amp;lt;number&amp;gt;
Minor version for cmake and DLL version stamping.
 OUTCOME_VERSION_PATCH &amp;lt;number&amp;gt;
Patch version for cmake and DLL version stamping.
 OUTCOME_VERSION_REVISION &amp;lt;number&amp;gt;
Revision version for cmake and DLL version stamping.
 OUTCOME_UNSTABLE_VERSION &amp;lt;number&amp;gt;
Defined between stable releases of Outcome. It means the inline namespace will be permuted per-commit to ensure ABI uniqueness such that multiple versions of Outcome in a single process space cannot collide.</description>
    </item>
    
    <item>
      <title>`OUTCOME_DISABLE_EXECINFO`</title>
      <link>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</guid>
      <description>If defined, disables the use of the &amp;lt;execinfo.h&amp;gt; header (or the win32 emulation).
Some embedded Linux toolchains do not define &amp;lt;execinfo.h&amp;gt;, thus disabling C++ exceptions on those toolchains produces a failure to find this file. Avoid that problem by defining this macro to disable stack backtrace support entirely.
Overridable: Define before inclusion.
Default: Defined if __ANDROID__ is defined, else undefined.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_NODISCARD`</title>
      <link>https://ned14.github.io/outcome/reference/macros/nodiscard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/nodiscard/</guid>
      <description>Compiler-specific markup used to tell the compiler than the return value of a function should not be discarded without examining it.
Overridable: Define before inclusion.
Default: To [[nodiscard]] if on C++ 17 or higher, __attribute__((warn_unused_result)) if on clang, SAL _Must_inspect_result_ if on MSVC, otherwise nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_REQUIRES(...)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/requires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/requires/</guid>
      <description>A C++ 20 requires(...), if available.
Overridable: Define before inclusion.
Default: To requires(...) if on C++ 20 or later, else to nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_SYMBOL_VISIBLE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/symbol_visible/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/symbol_visible/</guid>
      <description>Compiler-specific markup used to mark throwable types as always having default ELF symbol visibility, without which it will be impossible to catch throws of such types across shared library boundaries on ELF only.
Overridable: Define before inclusion.
Default: Standalone Outcome: To __attribute__((visibility(&amp;quot;default&amp;quot;)) on GCC and clang when targeting ELF, otherwise nothing. Boost.Outcome: To BOOST_SYMBOL_VISIBLE. 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THREAD_LOCAL`</title>
      <link>https://ned14.github.io/outcome/reference/macros/thread_local/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/thread_local/</guid>
      <description>Compiler-specific markup used to mark variables as having thread local storage duration.
This isn&amp;rsquo;t used inside Outcome, but is used by its unit test suite.
 Overridable: Define before inclusion.
Default: To thread_local if the compiler implements C++ 11 thread_local, else __thread for the one supported compiler (older Mac OS XCode) which does not.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THROW_EXCEPTION(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/throw_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/throw_exception/</guid>
      <description>Throws a C++ exception, or equivalent thereof.
Overridable: Define before inclusion.
Default: Standalone Outcome (C++ exceptions enabled): To throw expr Standalone Outcome (C++ exceptions disabled): To OUTCOME_V2_NAMESPACE::detail::do_fatal_exit(#expr) which is a function which prints a useful error message including a stack backtrace (where available) to stderr before calling abort(). Boost.Outcome: To BOOST_THROW_EXCEPTION(expr). 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/try/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, assigning T to a variable called var if successful, immediately returning E from the calling function if unsuccessful.
Overridable: Not overridable.
Definition: See OUTCOME_TRYV(expr) for most of the mechanics.
If successful, an auto &amp;amp;&amp;amp;var is initialised to the expression result&amp;rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV(expr)/OUTCOME_TRY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, continuing execution if successful, immediately returning E from the calling function if unsuccessful.
The difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr)). The former requires the T to be void.
Overridable: Not overridable.
Definition: Firstly the expression&amp;rsquo;s temporary is bound to a uniquely named, stack allocated, auto &amp;amp;&amp;amp;.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYX(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryx/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, emitting the T if successful, immediately returning E from the calling function if unsuccessful.
Availability: GCC and clang only. Use #ifdef OUTCOME_TRYX to determine if available.
Overridable: Not overridable.
Definition: See OUTCOME_TRYV(expr) for most of the mechanics.
This macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_TRYX(expr) directly in expressions e.</description>
    </item>
    
    <item>
      <title>`ValueOrError&lt;T, E&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/valueorerror/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/valueorerror/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, a public .value() observer function, and a public .error() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches expected-like types such as  P0323 std::expected&amp;lt;T, E&amp;gt;, one of which is basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.</description>
    </item>
    
    <item>
      <title>`ValueOrNone&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/valueornone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/valueornone/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, and a public .value() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches optional-like types such as  std::optional&amp;lt;T&amp;gt;. Note it also matches  P0323 std::expected&amp;lt;T, E&amp;gt;, which also has an optional-like interface.</description>
    </item>
    
    <item>
      <title>`has_error_code&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/has_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/has_error_code/</guid>
      <description>True if an error code can be constructed from a T e.g. if there exists an ADL discovered free function make_error_code(T) and it returns an error code.
Overridable: By template specialisation into the trait namespace.
Default: True if T is implicitly constructible to an error code, else to metaprogramming which performs the ADL discovery and testing of the result type of make_error_code(T). Note that the STL defines multiple overloads of an ADL discovered free function  std::make_error_code(T) for its error enumerations, as does Boost.</description>
    </item>
    
    <item>
      <title>`has_exception_ptr&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/has_exception_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/has_exception_ptr/</guid>
      <description>True if an exception ptr can be constructed from a T e.g. if there exists an ADL discovered free function make_exception_ptr(T) and it returns an exception ptr.
Overridable: By template specialisation into the trait namespace.
Default: True if T is implicitly constructible to an exception ptr, else to metaprogramming which performs the ADL discovery and testing of the result type of make_exception_ptr(T). Note that the STL defines an ADL discovered free function  std::make_exception_ptr(T).</description>
    </item>
    
    <item>
      <title>`in_place_type_t&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/in_place_type_t/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/in_place_type_t/</guid>
      <description>Either std::in_place_type_t&amp;lt;T&amp;gt; if C++ 17 or later, else a local emulation.
Note that the templated variable in_place_type is also aliased or emulated locally.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/config.hpp&amp;gt;
Inclusions: &amp;lt;utility&amp;gt; if C++ 17 or later only, for  std::in_place_type_t&amp;lt;T&amp;gt;.</description>
    </item>
    
    <item>
      <title>`is_basic_result&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_basic_result/</guid>
      <description>An integral constant type true for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;
Variable alias: is_basic_result_v&amp;lt;T&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_error_type&lt;E&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type/</guid>
      <description>A customisable integral constant type true for E types which are to receive error throwing no-value policies.
Overridable: By template specialisation into the trait namespace.
Default: False. Specialisations to true exist for:
 &amp;lt;outcome/boost_result.hpp&amp;gt;
 boost::system::error_code boost::system::errc::errc_t boost::exception_ptr  &amp;lt;outcome/std_result.hpp&amp;gt;
 std::error_code std::errc std::exception_ptr   Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_error_type_enum&lt;E, Enum&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</guid>
      <description>A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies
Overridable: By template specialisation into the trait namespace.
Default: False. Specialisations exist for:
 &amp;lt;outcome/boost_result.hpp&amp;gt;
 boost::system::error_code to boost::system::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.  &amp;lt;outcome/std_result.hpp&amp;gt;
 std::error_code to std::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.   Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`type_can_be_used_in_basic_result&lt;R&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</guid>
      <description>A constexpr boolean true for types permissible in basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.
Overridable: Not overridable.
Definition: True for a type which:
 Is not a reference. Is not an in_place_type_t&amp;lt;T&amp;gt;. Is not a API NOT FOUND IN DOCS success_type&amp;lt;T&amp;gt;. Is not a API NOT FOUND IN DOCS failure_type&amp;lt;E, P&amp;gt;. Is not an array. Is either void, or else is an Object and is Destructible.  Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
  </channel>
</rss>