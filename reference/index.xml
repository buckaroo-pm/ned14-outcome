<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>API reference on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/reference/</link>
    <description>Recent content in API reference on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 30 May 2018 22:12:35 +0100</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/reference/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>outcome&lt;R, S, P&gt;</title>
      <link>https://ned14.github.io/outcome/reference/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/outcome/</guid>
      <description>Header file outcome.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;using is_outcome&amp;nbsp;=&amp;nbsp;&amp;#x27;hidden&amp;#x27;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;is_outcome_v&amp;nbsp;=&amp;nbsp;detail::is_outcome&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace&amp;nbsp;hooks &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_outcome_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_outcome_copy_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_outcome_move_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U,&amp;nbsp;class&amp;nbsp;...&amp;nbsp;Args&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_outcome_in_place_construction(T*, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;NoValuePolicy,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void override_outcome_exception(outcome&amp;lt;R, S, P, NoValuePolicy&amp;gt;*&amp;nbsp;o,&amp;nbsp;U&amp;amp;&amp;amp;&amp;nbsp;v)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class R,&amp;nbsp;class S,&amp;nbsp;class P,&amp;nbsp;class NoValuePolicy&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class outcome; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U,&amp;nbsp;class&amp;nbsp;V,&amp;nbsp;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;bool operator==(result&amp;lt;T, U, V&amp;gt;&amp;nbsp;const&amp;amp; a, outcome&amp;lt;R, S, P, N&amp;gt;&amp;nbsp;const&amp;amp; b)&amp;nbsp;noexcept(&amp;#x27;hidden&amp;#x27;); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U,&amp;nbsp;class&amp;nbsp;V,&amp;nbsp;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;bool operator!=(result&amp;lt;T, U, V&amp;gt;&amp;nbsp;const&amp;amp; a, outcome&amp;lt;R, S, P, N&amp;gt;&amp;nbsp;const&amp;amp; b)&amp;nbsp;noexcept(&amp;#x27;hidden&amp;#x27;); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void swap(outcome&amp;lt;R, S, P, N&amp;gt;&amp;amp;&amp;nbsp;a, outcome&amp;lt;R, S, P, N&amp;gt;&amp;amp;&amp;nbsp;b)&amp;nbsp;noexcept(&amp;#x27;hidden&amp;#x27;); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace&amp;nbsp;hooks &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;NoValuePolicy,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void override_outcome_exception(outcome&amp;lt;R, S, P, NoValuePolicy&amp;gt;* o,&amp;nbsp;U&amp;amp;&amp;amp; v)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} }</description>
    </item>
    
    <item>
      <title>result&lt;R, S&gt;</title>
      <link>https://ned14.github.io/outcome/reference/result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/result/</guid>
      <description>Header file result.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace policy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;EC,&amp;nbsp;class&amp;nbsp;E&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;using default_policy&amp;nbsp;=&amp;nbsp;std::conditional_t&amp;lt;std::is_void&amp;lt;EC&amp;gt;::value &amp;amp;&amp;amp; std::is_void&amp;lt;E&amp;gt;::value, terminate, std::conditional_t&amp;lt;trait::has_error_code_v&amp;lt;EC&amp;gt;, error_code_throw_as_system_error&amp;lt;T, EC, E&amp;gt;, std::conditional_t&amp;lt;trait::has_exception_ptr_v&amp;lt;EC&amp;gt; || trait::has_exception_ptr_v&amp;lt;E&amp;gt;, exception_ptr_rethrow&amp;lt;T, EC, E&amp;gt;, all_narrow&amp;gt; &amp;gt;&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;using is_result&amp;nbsp;=&amp;nbsp;&amp;#x27;hidden&amp;#x27;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;is_result_v&amp;nbsp;=&amp;nbsp;detail::is_result&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace hooks &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_result_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_result_copy_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_result_move_construction(T*,&amp;nbsp;U&amp;amp;&amp;amp;)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U,&amp;nbsp;class&amp;nbsp;...&amp;nbsp;Args&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void hook_result_in_place_construction(T*, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;NoValuePolicy&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;uint16_t spare_storage(&amp;#x27;hidden&amp;#x27;&amp;nbsp;const*&amp;nbsp;r)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;NoValuePolicy&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void set_spare_storage(&amp;#x27;hidden&amp;#x27;*&amp;nbsp;r,&amp;nbsp;uint16_t&amp;nbsp;v)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class R,&amp;nbsp;class S,&amp;nbsp;class NoValuePolicy&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class result; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void swap(result&amp;lt;R, S, P&amp;gt;&amp;amp;&amp;nbsp;a, result&amp;lt;R, S, P&amp;gt;&amp;amp;&amp;nbsp;b)&amp;nbsp;noexcept(&amp;#x27;hidden&amp;#x27;); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;is_result_v&amp;nbsp;=&amp;nbsp;detail::is_result&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;is_result_v&amp;nbsp;=&amp;nbsp;detail::is_result&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S&amp;nbsp;= std::error_code&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;using unchecked&amp;nbsp;= result&amp;lt;R, S, policy::all_narrow&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S&amp;nbsp;= std::error_code&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;using checked&amp;nbsp;= result&amp;lt;R, S, policy::throw_bad_result_access&amp;lt;S&amp;gt;&amp;gt;; }</description>
    </item>
    
    <item>
      <title>Try operations</title>
      <link>https://ned14.github.io/outcome/reference/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/try/</guid>
      <description>Header file try.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;auto try_operation_return_as(T&amp;amp;&amp;amp;&amp;nbsp;v); } #define OUTCOME_TRYV(...) #define OUTCOME_TRYX(...) #define OUTCOME_TRY(v,...)  
Function outcome_v2_xxx::try_operation_return_as 
template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; auto&amp;nbsp;try_operation_return_as(T&amp;amp;&amp;amp;&amp;nbsp;v);  Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::forward&amp;lt;T&amp;gt;(v).as_failure().
Effects: Extracts any state apart from value into a failure_type.
Requires: The input value to have a .as_failure() member function.
Macro OUTCOME_TRYV 
#define&amp;nbsp;OUTCOME_TRYV(...)&amp;nbsp;OUTCOME_TRYV2(OUTCOME_TRY_UNIQUE_NAME, __VA_ARGS__)  If the outcome returned by expression … is not valued, propagate any failure by immediately returning that failure state immediately</description>
    </item>
    
    <item>
      <title>Success/Failure</title>
      <link>https://ned14.github.io/outcome/reference/success_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/success_failure/</guid>
      <description>Header file success_failure.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace policy &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;auto error_code(T&amp;amp;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;auto exception_ptr(T&amp;amp;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;Error&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;void throw_as_system_error_with_payload(Error&amp;nbsp;const&amp;amp;&amp;nbsp;error); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace trait &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct has_error_code; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt;constexpr&amp;nbsp;bool&amp;nbsp;has_error_code_v&amp;nbsp;=&amp;nbsp;has_error_code&amp;lt;T&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct has_exception_ptr; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt;constexpr&amp;nbsp;bool&amp;nbsp;has_exception_ptr_v&amp;nbsp;=&amp;nbsp;has_exception_ptr&amp;lt;T&amp;gt;::value; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct success_type; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct success_type&amp;lt;void&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr success_type&amp;lt;void&amp;gt; success()&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr success_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt; success(T&amp;amp;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;EC&amp;nbsp;= std::error_code,&amp;nbsp;class&amp;nbsp;E&amp;nbsp;= void&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct failure_type; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;EC&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct failure_type&amp;lt;EC,&amp;nbsp;void&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;E&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct failure_type&amp;lt;void,&amp;nbsp;E&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;EC&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr failure_type&amp;lt;std::decay_t&amp;lt;EC&amp;gt;&amp;gt; failure(EC&amp;amp;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;EC,&amp;nbsp;class&amp;nbsp;E&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr failure_type&amp;lt;std::decay_t&amp;lt;EC&amp;gt;, std::decay_t&amp;lt;E&amp;gt;&amp;gt; failure(EC&amp;amp;&amp;amp;&amp;nbsp;v,&amp;nbsp;E&amp;amp;&amp;amp;&amp;nbsp;w); }  

Function outcome_v2_xxx::policy::error_code</description>
    </item>
    
    <item>
      <title>Utilities</title>
      <link>https://ned14.github.io/outcome/reference/utils/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/utils/</guid>
      <description>Header file utils.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::error_code error_from_exception(std::exception_ptr&amp;amp;&amp;amp; ep&amp;nbsp;=&amp;nbsp;std::current_exception(,&amp;nbsp;std::error_code not_matched&amp;nbsp;=&amp;nbsp;std::make_error_code(std::errc::resource_unavailable_try_again)&amp;nbsp;noexcept; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void try_throw_std_exception_from_error(std::error_code ec,&amp;nbsp;std::string&amp;nbsp;const&amp;amp; msg&amp;nbsp;=&amp;nbsp;std::string{); }  
Function outcome_v2_xxx::error_from_exception 
std::error_code&amp;nbsp;error_from_exception(std::exception_ptr&amp;amp;&amp;amp; ep&amp;nbsp;=&amp;nbsp;std::current_exception(,&amp;nbsp;std::error_code not_matched&amp;nbsp;=&amp;nbsp;std::make_error_code(std::errc::resource_unavailable_try_again)&amp;nbsp;noexcept;  Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types.
Effects: Rethrows the exception in the pointer, and via a long sequence of catch clauses attempts to match the equivalent error code.</description>
    </item>
    
    <item>
      <title>Interoperation</title>
      <link>https://ned14.github.io/outcome/reference/convert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/convert/</guid>
      <description>Header file convert.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace convert &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;U&amp;gt;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;ValueOrNone&amp;nbsp;=&amp;nbsp;detail::ValueOrNone&amp;lt;U&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;U&amp;gt;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;ValueOrError&amp;nbsp;=&amp;nbsp;detail::ValueOrError&amp;lt;U&amp;gt;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;struct value_or_error; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} }  

Struct outcome_v2_xxx::convert::value_or_error 
template&amp;nbsp;&amp;lt;class&amp;nbsp;T,&amp;nbsp;class&amp;nbsp;U&amp;gt; struct&amp;nbsp;value_or_error { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;const enable_result_inputs; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;constexpr&amp;nbsp;bool&amp;nbsp;const enable_outcome_inputs; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;X,&amp;nbsp;typename&amp;nbsp;= std::enable_if_t&amp;lt;std::is_same&amp;lt;U,std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value&amp;amp;&amp;amp;ValueOrError&amp;lt;U&amp;gt;&amp;amp;&amp;amp;(std::is_void&amp;lt;typename std::decay_t&amp;lt;X&amp;gt;::value_type&amp;gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible&amp;lt;typename T::value_type,typename std::decay_t&amp;lt;X&amp;gt;::value_type&amp;gt;)&amp;amp;&amp;amp;(std::is_void&amp;lt;typename std::decay_t&amp;lt;X&amp;gt;::error_type&amp;gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible&amp;lt;typename T::error_type,typename std::decay_t&amp;lt;X&amp;gt;::error_type&amp;gt;)&amp;gt;&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;constexpr&amp;nbsp;T operator()(X&amp;amp;&amp;amp;&amp;nbsp;v); };  Default converter for types matching the ValueOrError concept.
You can partially or fully specialise this converter for your own user defined types by injecting specialisations into the convert namespace.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://ned14.github.io/outcome/reference/bad_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/bad_access/</guid>
      <description>Header file bad_access.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class bad_result_access; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;S&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class bad_result_access_with; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class bad_outcome_access; }  
Class outcome_v2_xxx::bad_result_access 
class&amp;nbsp;bad_result_access :&amp;nbsp;public&amp;nbsp;std::logic_error { public: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;explicit&amp;nbsp;bad_result_access(char&amp;nbsp;const*&amp;nbsp;what); };  Thrown when you try to access state in a result&amp;lt;R, S&amp;gt; which isn’t present.
Class outcome_v2_xxx::bad_result_access_with 
template&amp;nbsp;&amp;lt;class&amp;nbsp;S&amp;gt; class&amp;nbsp;bad_result_access_with :&amp;nbsp;public&amp;nbsp;bad_result_access { public: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;explicit&amp;nbsp;bad_result_access_with(S&amp;nbsp;v); &amp;#x2F;&amp;#x2F;=== result_error ===&amp;#x2F;&amp;#x2F; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;S&amp;nbsp;const&amp;amp; error()&amp;nbsp;const&amp;nbsp;&amp;amp;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;S&amp;amp; error()&amp;nbsp;&amp;amp;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;S&amp;nbsp;const&amp;amp;&amp;amp; error()&amp;nbsp;const&amp;nbsp;&amp;amp;&amp;amp;; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;S&amp;amp;&amp;amp; error()&amp;nbsp;&amp;amp;&amp;amp;; };  Thrown when you try to access a value in a result&amp;lt;R, S&amp;gt; which isn’t present.</description>
    </item>
    
    <item>
      <title>iostream support</title>
      <link>https://ned14.github.io/outcome/reference/iostream_support/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/iostream_support/</guid>
      <description>Header file iostream_support.hpp 
namespace&amp;nbsp;outcome_v2_xxx { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp;&amp;nbsp;s, result&amp;lt;R, S, P&amp;gt;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp;&amp;nbsp;s, result&amp;lt;R, S, P&amp;gt;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::string print(&amp;#x27;hidden&amp;#x27;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::string print(&amp;#x27;hidden&amp;#x27;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::string print(&amp;#x27;hidden&amp;#x27;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;P&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::string print(&amp;#x27;hidden&amp;#x27;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::istream&amp;amp; operator&amp;gt;&amp;gt;(std::istream&amp;amp;&amp;nbsp;s, outcome&amp;lt;R, S, P, N&amp;gt;&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp;&amp;nbsp;s, outcome&amp;lt;R, S, P, N&amp;gt;&amp;nbsp;const&amp;amp;&amp;nbsp;v); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P,&amp;nbsp;class&amp;nbsp;N&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::string print(outcome&amp;lt;R, S, P, N&amp;gt;&amp;nbsp;const&amp;amp;&amp;nbsp;v); }  
Function outcome_v2_xxx::operator&amp;gt;&amp;gt; 
template&amp;nbsp;&amp;lt;class&amp;nbsp;R,&amp;nbsp;class&amp;nbsp;S,&amp;nbsp;class&amp;nbsp;P&amp;gt; std::istream&amp;amp;&amp;nbsp;operator&amp;gt;&amp;gt;(std::istream&amp;amp;&amp;nbsp;s, result&amp;lt;R, S, P&amp;gt;&amp;amp;&amp;nbsp;v);  Deserialise a result. Format is status_unsigned [value][error]. Spare storage is preserved.</description>
    </item>
    
    <item>
      <title>C API</title>
      <link>https://ned14.github.io/outcome/reference/result_c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/result_c/</guid>
      <description>Header file result_c 
struct cxx_error_code; #define CXX_DECLARE_RESULT(R,RD,S,SD) #define CXX_DECLARE_RESULT_EC(R,RD) #define CXX_RESULT(R,S) #define CXX_RESULT_EC(R) #define CXX_RESULT_HAS_VALUE(r) #define CXX_RESULT_HAS_ERROR(r) #define CXX_RESULT_ERROR_IS_ERRNO(r) #define CXX_RESULT_ERROR(r) #define CXX_RESULT_SET_ERRNO(r)  Struct cxx_error_code 
struct&amp;nbsp;cxx_error_code { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;code; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void*&amp;nbsp;category; };  A C struct representation of std::error_code.
Macro CXX_DECLARE_RESULT 
#define&amp;nbsp;CXX_DECLARE_RESULT(R,RD,S,SD)&amp;nbsp;struct result_##R##_##S { RD value; unsigned flags; SD error; }  Declares a C struct representation of result&amp;lt;R, S&amp;gt;.
Macro CXX_DECLARE_RESULT_EC 
#define&amp;nbsp;CXX_DECLARE_RESULT_EC(R,RD)&amp;nbsp;CXX_DECLARE_RESULT(R, RD, errorcode, struct cxx_error_code)  Declares a C struct representation of result&amp;lt;R, std::error_code&amp;gt;.</description>
    </item>
    
  </channel>
</rss>